<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shashka PRO - Haqiqiy AI O'yin</title>
    <style>
        /* ==================== UMUMIY STILLAR ==================== */
        :root {
            --size: min(92vmin, 640px);
            --light: #f5f5dc;
            --dark: #8b4513;
            --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --piece-white: linear-gradient(135deg, #ffffff, #f0f0f0);
            --piece-black: linear-gradient(135deg, #2c3e50, #34495e);
            --king-gold: linear-gradient(135deg, #fbb034, #ffdd00);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }
        
        h1 {
            text-align: center;
            color: white;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: #e0e0e0;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
        }
        
        /* ==================== DOSKA STILLARI ==================== */
        .board-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .board {
            width: var(--size);
            height: var(--size);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            position: relative;
        }
        
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .cell.light {
            background: linear-gradient(135deg, #f5e6d3, #e8d9c5);
        }
        
        .cell.dark {
            background: linear-gradient(135deg, var(--dark), #a0522d);
        }
        
        .cell.dark:hover:not(.has-piece) {
            background: linear-gradient(135deg, #a0522d, #8b4513);
        }
        
        /* ==================== DOSKALAR STILLARI ==================== */
        .piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 15px rgba(0, 0, 0, 0.2),
                inset 0 -3px 8px rgba(0, 0, 0, 0.1),
                inset 0 3px 8px rgba(255, 255, 255, 0.2);
            z-index: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .piece.white {
            background: var(--piece-white);
            border: 2px solid #d0d0d0;
        }
        
        .piece.black {
            background: var(--piece-black);
            border: 2px solid #1a1a1a;
        }
        
        .piece.king {
            border-width: 3px;
            border-style: solid;
            border-image: var(--king-gold) 1;
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.3),
                inset 0 -4px 10px rgba(0, 0, 0, 0.15),
                inset 0 4px 10px rgba(255, 255, 255, 0.3),
                0 0 20px rgba(255, 215, 0, 0.3);
        }
        
        .king-symbol {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.8rem;
            color: gold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 3;
            pointer-events: none;
        }
        
        /* ==================== ANIMATSIYALAR ==================== */
        @keyframes selected {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); }
            100% { transform: scale(1.1); }
        }
        
        @keyframes moveDot {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @keyframes pieceMove {
            0% { transform: translate(var(--start-x), var(--start-y)) scale(1); }
            100% { transform: translate(var(--end-x), var(--end-y)) scale(1); }
        }
        
        @keyframes captureEffect {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        @keyframes penaltyFlash {
            0%, 100% { background-color: #ff4444; }
            50% { background-color: #ff8888; }
        }
        
        @keyframes winAnimation {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .piece.selected {
            animation: selected 0.5s ease-out forwards;
            box-shadow: 
                0 0 0 4px rgba(66, 153, 225, 0.8),
                0 8px 25px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        .piece.must-capture {
            box-shadow: 
                0 0 0 4px rgba(239, 68, 68, 0.8),
                0 8px 25px rgba(239, 68, 68, 0.3);
        }
        
        .move-dot {
            position: absolute;
            width: 20%;
            height: 20%;
            border-radius: 50%;
            background: rgba(255, 215, 0, 0.9);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            z-index: 1;
            animation: moveDot 0.3s ease-out forwards;
            pointer-events: none;
        }
        
        .capture-dot {
            background: rgba(255, 50, 50, 0.9);
            box-shadow: 0 0 10px rgba(255, 50, 50, 0.5);
        }
        
        .piece.moving {
            animation: pieceMove 0.4s ease-out forwards;
            z-index: 100;
        }
        
        .piece.capturing {
            animation: captureEffect 0.5s ease-out forwards;
            z-index: 99;
        }
        
        /* ==================== MODAL OYNA ==================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .modal-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .modal {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }
        
        .modal-overlay.active .modal {
            transform: translateY(0);
        }
        
        .modal h2 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* ==================== RANG TANLASH ==================== */
        .color-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 25px 0;
        }
        
        .color-option {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .color-option:hover {
            transform: scale(1.1);
        }
        
        .color-option.selected {
            border-color: #4299e1;
            box-shadow: 0 0 25px rgba(66, 153, 225, 0.5);
        }
        
        .color-option.white {
            background: var(--piece-white);
            border: 2px solid #ccc;
        }
        
        .color-option.black {
            background: var(--piece-black);
            border: 2px solid #333;
        }
        
        .color-option.random {
            background: linear-gradient(135deg, #fff 50%, #000 50%);
        }
        
        .color-option .color-label {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 0.9rem;
            white-space: nowrap;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        /* ==================== QIYINCHILIK TANLASH ==================== */
        .difficulty-section {
            margin: 25px 0;
            text-align: center;
        }
        
        .difficulty-label {
            color: white;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .difficulty-slider {
            width: 100%;
            max-width: 300px;
            height: 20px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #4ade80, #fbbf24, #ef4444);
            border-radius: 10px;
            outline: none;
            margin: 15px 0;
        }
        
        .difficulty-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            border: 2px solid #4299e1;
        }
        
        .difficulty-value {
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            margin-top: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        /* ==================== REJIM TANLASH ==================== */
        .mode-selection {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        
        .mode-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .mode-btn.active {
            background: #4299e1;
            box-shadow: 0 5px 15px rgba(66, 153, 225, 0.4);
        }
        
        /* ==================== BOSHLASH TUGMASI ==================== */
        .start-btn {
            padding: 16px 40px;
            font-size: 1.2rem;
            font-weight: bold;
            background: linear-gradient(135deg, #4299e1, #3182ce);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            box-shadow: 0 10px 20px rgba(66, 153, 225, 0.3);
            letter-spacing: 1px;
        }
        
        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 25px rgba(66, 153, 225, 0.4);
            background: linear-gradient(135deg, #3182ce, #2c5282);
        }
        
        /* ==================== KONTROL PANELI ==================== */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin: 25px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .control-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* ==================== INFO PANELI ==================== */
        .info-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }
        
        .info-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            min-width: 250px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .info-card h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 8px;
        }
        
        .info-item {
            margin: 10px 0;
            color: #e0e0e0;
            font-size: 0.95rem;
        }
        
        .info-item strong {
            color: white;
            font-weight: 600;
        }
        
        .player-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 10px 0;
        }
        
        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .player-color.white {
            background: var(--piece-white);
        }
        
        .player-color.black {
            background: var(--piece-black);
        }
        
        .penalty-warning {
            color: #ff6b6b;
            font-weight: bold;
            animation: penaltyFlash 1s ease-in-out 3;
        }
        
        /* ==================== O'YIN TUGASH MODALI ==================== */
        .game-over-modal {
            text-align: center;
        }
        
        .game-over-text {
            font-size: 3rem;
            font-weight: bold;
            margin: 30px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .game-over-text.win {
            background: linear-gradient(135deg, #4ade80, #22d3ee);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: winAnimation 1s ease-in-out infinite;
        }
        
        .game-over-text.lose {
            background: linear-gradient(135deg, #ef4444, #f87171);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        /* ==================== RESPONSIVE DESIGN ==================== */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .board-container {
                padding: 15px;
            }
            
            .color-option {
                width: 60px;
                height: 60px;
            }
            
            .modal {
                padding: 25px;
            }
            
            .controls {
                padding: 15px;
            }
            
            .control-btn {
                padding: 10px 18px;
                font-size: 0.9rem;
            }
            
            .info-panel {
                flex-direction: column;
                align-items: center;
            }
            
            .info-card {
                width: 100%;
                max-width: 400px;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.7rem;
            }
            
            .color-options {
                gap: 10px;
            }
            
            .color-option {
                width: 50px;
                height: 50px;
            }
            
            .mode-selection {
                flex-direction: column;
            }
            
            .mode-btn {
                width: 100%;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .control-btn {
                width: 100%;
                justify-content: center;
            }
        }
        
        /* ==================== QO'SHIMCHA ELEMENTLAR ==================== */
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
        }
        
        .checkbox-container input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .status-message {
            text-align: center;
            color: white;
            font-size: 1.1rem;
            margin: 15px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top-color: #4299e1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ Shashka PRO</h1>
        <div class="subtitle">Haqiqiy AI bilan ziddiyatli shashka jangi</div>
        
        <!-- Asosiy modal oyna -->
        <div id="mainModal" class="modal-overlay active">
            <div class="modal">
                <h2>üéÆ O'yinni Boshlash</h2>
                
                <!-- Rang tanlash -->
                <div style="text-align: center; margin: 20px 0;">
                    <div style="color: white; margin-bottom: 15px; font-size: 1.1rem;">O'ynash uchun rang tanlang:</div>
                    <div class="color-options">
                        <div class="color-option white selected" onclick="selectColor('white')">
                            <div class="color-label">Oq</div>
                        </div>
                        <div class="color-option black" onclick="selectColor('black')">
                            <div class="color-label">Qora</div>
                        </div>
                        <div class="color-option random" onclick="selectColor('random')">
                            <div class="color-label">Tasodifiy</div>
                        </div>
                    </div>
                </div>
                
                <!-- Qiyinchilik darajasi -->
                <div class="difficulty-section">
                    <div class="difficulty-label">Qiyinchilik darajasi:</div>
                    <input type="range" min="1" max="12" value="8" class="difficulty-slider" id="difficultySlider">
                    <div class="difficulty-value" id="difficultyValue">8 - Professional</div>
                </div>
                
                <!-- O'yin rejimi -->
                <div style="text-align: center; margin: 20px 0;">
                    <div style="color: white; margin-bottom: 15px; font-size: 1.1rem;">O'yin rejimi:</div>
                    <div class="mode-selection">
                        <button class="mode-btn active" onclick="selectMode('single')">ü§ñ AI bilan</button>
                    </div>
                </div>
                
                <!-- Rang ma'lumoti -->
                <div id="colorInfo" style="color: #4299e1; text-align: center; margin: 20px 0; font-weight: bold; font-size: 1.1rem;">
                    Siz: Oq | Bot: Qora
                </div>
                
                <!-- Boshlash tugmasi -->
                <div style="text-align: center;">
                    <button class="start-btn" onclick="startGame()">üéÆ O'yinni Boshlash</button>
                </div>
            </div>
        </div>
        
        <!-- O'yin maydoni (dastlab yashirin) -->
        <div id="gameArea" style="display: none; width: 100%;">
            <div class="board-container">
                <div class="board" id="board"></div>
            </div>
            
            <!-- Status xabari -->
            <div class="status-message" id="statusMessage">Dona tanlang...</div>
            
            <!-- Kontrol paneli -->
            <div class="controls">
                <button class="control-btn" onclick="newGame()">
                    <span>üîÑ</span> Yangi o'yin
                </button>
                <button class="control-btn" id="undoBtn" onclick="undoMove()" disabled>
                    <span>‚Ü©Ô∏è</span> Orqaga
                </button>
                <button class="control-btn" id="redoBtn" onclick="redoMove()" disabled>
                    <span>‚Ü™Ô∏è</span> Oldinga
                </button>
                
                <!-- Qo'shimcha opsiyalar -->
                <div class="checkbox-container">
                    <input type="checkbox" id="autoBot" checked>
                    <label for="autoBot">Bot avtomatik</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="forceCapture" checked>
                    <label for="forceCapture">Majburiy olish</label>
                </div>
            </div>
            
            <!-- Ma'lumot paneli -->
            <div class="info-panel">
                <div class="info-card">
                    <h3>üìä O'yin holati</h3>
                    <div class="info-item">
                        <strong>Navbat:</strong> <span id="currentTurn">Siz (oq)</span>
                    </div>
                    <div class="info-item">
                        <strong>Donalar:</strong> <span id="pieceCount">Oq: 12 | Qora: 12</span>
                    </div>
                    <div class="info-item">
                        <strong>Jarimalar:</strong> <span id="penaltyCount">0/3</span>
                    </div>
                </div>
                
                <div class="info-card">
                    <h3>ü§ñ Bot ma'lumoti</h3>
                    <div class="info-item">
                        <strong>Daraja:</strong> <span id="botDifficulty">Professional (8)</span>
                    </div>
                    <div class="info-item">
                        <strong>Qidiruv:</strong> <span id="botSearch">0 daraja, 0ms</span>
                    </div>
                    <div class="info-item">
                        <strong>Harakatlar:</strong> <span id="botMoves">0 ta</span>
                    </div>
                </div>
                
                <div class="info-card">
                    <h3>üë• O'yinchilar</h3>
                    <div class="player-indicator" id="player1Indicator">
                        <div class="player-color white"></div>
                        <span>Siz (oq)</span>
                    </div>
                    <div class="player-indicator" id="player2Indicator">
                        <div class="player-color black"></div>
                        <span>Bot (qora)</span>
                    </div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--piece-white);"></div>
                            <span>Oddiy dona</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: gold;"></div>
                            <span>Dama</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- O'yin tugashi modal oynasi -->
        <div id="gameOverModal" class="modal-overlay">
            <div class="modal game-over-modal">
                <h2>üéâ O'yin Tugadi!</h2>
                <div class="game-over-text" id="gameResultText">Siz yutdingiz!</div>
                <div style="color: #e0e0e0; margin: 20px 0; font-size: 1.1rem;">
                    O'yin davomiyligi: <span id="gameDuration">0</span> daqiqa
                </div>
                <button class="start-btn" onclick="showMainMenu()">üè† Bosh menyu</button>
                <button class="start-btn" onclick="newGame()" style="margin-top: 15px; background: linear-gradient(135deg, #4ade80, #22c55e);">
                    üîÑ Yangi o'yin
                </button>
            </div>
        </div>
        
        <!-- Yuklanish indikatori -->
        <div id="loading" class="loading">
            <div class="spinner"></div>
        </div>
    </div>

    <script>
        // ==================== O'ZGARUVCHILAR VA HOLAT ====================
        let board = [];
        let history = [];
        let historyIndex = -1;
        let selectedPiece = null;
        let validMoves = [];
        let currentPlayer = 'white'; // Oq har doim boshlaydi
        let playerColor = 'white';
        let botColor = 'black';
        let gameMode = 'single';
        let difficulty = 8;
        let autoBot = true;
        let forceCapture = true;
        let penaltyCount = 0;
        let moveHistory = [];
        let pieceCount = { white: 12, black: 12 };
        let kingCount = { white: 0, black: 0 };
        let gameActive = false;
        let gameStartTime = null;
        let ai = null;
        
        // DOM elementlari
        const mainModal = document.getElementById('mainModal');
        const gameArea = document.getElementById('gameArea');
        const boardElement = document.getElementById('board');
        const statusMessage = document.getElementById('statusMessage');
        const currentTurn = document.getElementById('currentTurn');
        const pieceCountElement = document.getElementById('pieceCount');
        const penaltyCountElement = document.getElementById('penaltyCount');
        const botDifficulty = document.getElementById('botDifficulty');
        const botSearch = document.getElementById('botSearch');
        const botMoves = document.getElementById('botMoves');
        const gameOverModal = document.getElementById('gameOverModal');
        const gameResultText = document.getElementById('gameResultText');
        const gameDuration = document.getElementById('gameDuration');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const loading = document.getElementById('loading');
        
        // ==================== AI ENGINE ====================
        class CheckersAI {
            constructor(difficulty) {
                this.difficulty = difficulty;
                this.maxDepth = this.calculateDepth(difficulty);
                this.transpositionTable = new Map();
                this.nodesEvaluated = 0;
                this.maxTime = 1000 + (difficulty * 100);
                this.killerMoves = new Array(20).fill().map(() => []);
                
                // Baholash og'irliklari
                this.PIECE_VALUE = 100;
                this.KING_VALUE = 300;
                this.CENTER_BONUS = 15;
                this.BACK_ROW_BONUS = 20;
                this.MOBILITY_BONUS = 8;
                this.PROMOTION_BONUS = 50;
                
                this.stats = {
                    depth: 0,
                    nodes: 0,
                    time: 0,
                    moves: 0
                };
            }
            
            calculateDepth(difficulty) {
                return Math.min(3 + Math.floor(difficulty * 0.6), 10);
            }
            
            evaluate(board, color) {
                let score = 0;
                let pieceCount = { white: 0, black: 0 };
                let kingCount = { white: 0, black: 0 };
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (!piece) continue;
                        
                        const isWhite = piece.color === 'white';
                        let pieceScore = piece.king ? this.KING_VALUE : this.PIECE_VALUE;
                        
                        if (!piece.king) {
                            if (isWhite) {
                                pieceScore += (7 - r) * 5;
                                if (r === 7) pieceScore += this.BACK_ROW_BONUS;
                            } else {
                                pieceScore += r * 5;
                                if (r === 0) pieceScore += this.BACK_ROW_BONUS;
                            }
                        } else {
                            const centerDist = Math.abs(c - 3.5) + Math.abs(r - 3.5);
                            pieceScore += (7 - centerDist) * this.CENTER_BONUS;
                        }
                        
                        if (c >= 2 && c <= 5 && r >= 2 && r <= 5) {
                            pieceScore += this.CENTER_BONUS;
                        }
                        
                        if (isWhite) {
                            score += pieceScore;
                            pieceCount.white++;
                            if (piece.king) kingCount.white++;
                        } else {
                            score -= pieceScore;
                            pieceCount.black++;
                            if (piece.king) kingCount.black++;
                        }
                    }
                }
                
                const whiteMoves = this.getAllMoves(board, 'white').length;
                const blackMoves = this.getAllMoves(board, 'black').length;
                score += (whiteMoves - blackMoves) * this.MOBILITY_BONUS;
                
                return color === 'white' ? score : -score;
            }
            
            getAllMoves(board, color) {
                const moves = [];
                const captures = [];
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece && piece.color === color) {
                            const pieceMoves = this.getMovesForPiece(board, r, c, piece);
                            for (const move of pieceMoves) {
                                if (move.captures && move.captures.length > 0) {
                                    captures.push(move);
                                } else {
                                    moves.push(move);
                                }
                            }
                        }
                    }
                }
                
                if (captures.length > 0) {
                    return captures;
                }
                
                return moves;
            }
            
            getMovesForPiece(board, r, c, piece, visited = new Set()) {
                const moves = [];
                const dirs = piece.king ? 
                    [[1,1], [1,-1], [-1,1], [-1,-1]] :
                    (piece.color === 'white' ? [[-1,1], [-1,-1]] : [[1,1], [1,-1]]);
                
                for (const [dr, dc] of dirs) {
                    if (piece.king) {
                        let nr = r + dr, nc = c + dc;
                        while (this.isValid(nr, nc) && !board[nr][nc]) {
                            moves.push({
                                from: [r, c],
                                to: [nr, nc],
                                captures: [],
                                path: [[r, c], [nr, nc]]
                            });
                            nr += dr;
                            nc += dc;
                        }
                    } else {
                        const nr = r + dr, nc = c + dc;
                        if (this.isValid(nr, nc) && !board[nr][nc]) {
                            moves.push({
                                from: [r, c],
                                to: [nr, nc],
                                captures: [],
                                path: [[r, c], [nr, nc]]
                            });
                        }
                    }
                    
                    const captureMoves = this.getCaptureMoves(board, r, c, piece, visited);
                    moves.push(...captureMoves);
                }
                
                return moves;
            }
            
            getCaptureMoves(board, r, c, piece, visited) {
                const moves = [];
                const dirs = piece.king ? 
                    [[1,1], [1,-1], [-1,1], [-1,-1]] :
                    (piece.color === 'white' ? [[-1,1], [-1,-1]] : [[1,1], [1,-1]]);
                
                for (const [dr, dc] of dirs) {
                    const mr = r + dr, mc = c + dc;
                    const lr = mr + dr, lc = mc + dc;
                    
                    if (this.isValid(mr, mc) && this.isValid(lr, lc) &&
                        board[mr][mc] && board[mr][mc].color !== piece.color &&
                        !board[lr][lc]) {
                        
                        const captureKey = `${mr},${mc}`;
                        if (visited.has(captureKey)) continue;
                        
                        const newVisited = new Set(visited);
                        newVisited.add(captureKey);
                        
                        const newBoard = this.applyMove(board, {
                            from: [r, c],
                            to: [lr, lc],
                            captures: [[mr, mc]]
                        });
                        
                        const furtherCaptures = this.getCaptureMoves(newBoard, lr, lc, piece, newVisited);
                        
                        if (furtherCaptures.length > 0) {
                            for (const furtherMove of furtherCaptures) {
                                moves.push({
                                    from: [r, c],
                                    to: furtherMove.to,
                                    captures: [[mr, mc], ...furtherMove.captures],
                                    path: [[r, c], ...furtherMove.path.slice(1)]
                                });
                            }
                        } else {
                            moves.push({
                                from: [r, c],
                                to: [lr, lc],
                                captures: [[mr, mc]],
                                path: [[r, c], [lr, lc]]
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            applyMove(board, move) {
                const newBoard = JSON.parse(JSON.stringify(board));
                const piece = newBoard[move.from[0]][move.from[1]];
                newBoard[move.from[0]][move.from[1]] = null;
                newBoard[move.to[0]][move.to[1]] = piece;
                
                if (move.captures) {
                    move.captures.forEach(([r, c]) => {
                        newBoard[r][c] = null;
                    });
                }
                
                if (!piece.king) {
                    if ((piece.color === 'white' && move.to[0] === 0) ||
                        (piece.color === 'black' && move.to[0] === 7)) {
                        piece.king = true;
                    }
                }
                
                return newBoard;
            }
            
            getBestMove(board, color) {
                const startTime = Date.now();
                this.stats = { depth: 0, nodes: 0, time: 0, moves: 0 };
                this.transpositionTable.clear();
                
                const moves = this.getAllMoves(board, color);
                this.stats.moves = moves.length;
                
                if (moves.length === 0) return null;
                
                let bestMove = moves[0];
                let bestScore = -Infinity;
                let depth = 1;
                
                while (depth <= this.maxDepth && (Date.now() - startTime) < this.maxTime * 0.8) {
                    let currentBestMove = moves[0];
                    let currentBestScore = -Infinity;
                    let alpha = -Infinity;
                    let beta = Infinity;
                    
                    for (const move of moves) {
                        if ((Date.now() - startTime) > this.maxTime * 0.9) break;
                        
                        const newBoard = this.applyMove(board, move);
                        const score = -this.alphaBeta(
                            newBoard,
                            depth - 1,
                            -beta,
                            -alpha,
                            color === 'white' ? 'black' : 'white',
                            startTime
                        );
                        
                        if (score > currentBestScore) {
                            currentBestScore = score;
                            currentBestMove = move;
                        }
                        
                        alpha = Math.max(alpha, score);
                        if (alpha >= beta) break;
                    }
                    
                    if (currentBestScore > bestScore || 
                        (currentBestScore === bestScore && Math.random() > 0.5)) {
                        bestScore = currentBestScore;
                        bestMove = currentBestMove;
                    }
                    
                    this.stats.depth = depth;
                    depth++;
                }
                
                this.stats.time = Date.now() - startTime;
                this.stats.nodes = this.nodesEvaluated;
                
                return bestMove;
            }
            
            alphaBeta(board, depth, alpha, beta, color, startTime) {
                this.nodesEvaluated++;
                
                if ((Date.now() - startTime) > this.maxTime) {
                    return this.evaluate(board, color);
                }
                
                if (depth <= 0) {
                    return this.evaluate(board, color);
                }
                
                const moves = this.getAllMoves(board, color);
                if (moves.length === 0) {
                    return -Infinity;
                }
                
                let bestScore = -Infinity;
                
                for (const move of moves) {
                    if ((Date.now() - startTime) > this.maxTime) break;
                    
                    const newBoard = this.applyMove(board, move);
                    const score = -this.alphaBeta(
                        newBoard,
                        depth - 1,
                        -beta,
                        -alpha,
                        color === 'white' ? 'black' : 'white',
                        startTime
                    );
                    
                    bestScore = Math.max(bestScore, score);
                    alpha = Math.max(alpha, score);
                    if (alpha >= beta) break;
                }
                
                return bestScore;
            }
            
            isValid(r, c) {
                return r >= 0 && r < 8 && c >= 0 && c < 8;
            }
        }
        
        // ==================== UI FUNCTIONS ====================
        function selectColor(color) {
            if (color === 'random') {
                color = Math.random() > 0.5 ? 'white' : 'black';
            }
            playerColor = color;
            botColor = color === 'white' ? 'black' : 'white';
            
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            
            event.target.closest('.color-option').classList.add('selected');
            updateColorInfo();
        }
        
        function updateColorInfo() {
            const colorInfo = document.getElementById('colorInfo');
            colorInfo.textContent = `Siz: ${playerColor === 'white' ? 'Oq' : 'Qora'} | Bot: ${botColor === 'white' ? 'Oq' : 'Qora'}`;
        }
        
        function selectMode(mode) {
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        function updateDifficultyLabel() {
            const slider = document.getElementById('difficultySlider');
            const valueElement = document.getElementById('difficultyValue');
            const value = parseInt(slider.value);
            
            const labels = [
                '1 - Boshlang\'ich', '2', '3', '4', '5 - O\'rta',
                '6', '7', '8 - Professional', '9', '10',
                '11', '12 - Ustun'
            ];
            
            valueElement.textContent = labels[value - 1];
            difficulty = value;
        }
        
        function startGame() {
            mainModal.classList.remove('active');
            gameArea.style.display = 'block';
            initializeGame();
        }
        
        function showMainMenu() {
            gameOverModal.classList.remove('active');
            mainModal.classList.add('active');
            gameArea.style.display = 'none';
        }
        
        // ==================== O'YIN LOGIKASI ====================
        function initializeGame() {
            board = createInitialBoard();
            history = [JSON.parse(JSON.stringify(board))];
            historyIndex = 0;
            selectedPiece = null;
            validMoves = [];
            currentPlayer = 'white';
            penaltyCount = 0;
            pieceCount = { white: 12, black: 12 };
            kingCount = { white: 0, black: 0 };
            gameActive = true;
            gameStartTime = Date.now();
            moveHistory = [];
            
            autoBot = document.getElementById('autoBot').checked;
            forceCapture = document.getElementById('forceCapture').checked;
            
            ai = new CheckersAI(difficulty);
            
            updateUI();
            renderBoard();
            updateStatus();
            
            if (currentPlayer === botColor && autoBot) {
                setTimeout(makeBotMove, 500);
            }
        }
        
        function createInitialBoard() {
            const newBoard = Array(8).fill().map(() => Array(8).fill(null));
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if ((r + c) % 2 === 1) {
                        if (r < 3) {
                            newBoard[r][c] = { color: 'black', king: false };
                        } else if (r > 4) {
                            newBoard[r][c] = { color: 'white', king: false };
                        }
                    }
                }
            }
            
            return newBoard;
        }
        
        function renderBoard() {
            boardElement.innerHTML = '';
            
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    if (!selectedPiece || !gameActive) {
                        cell.onclick = () => onCellClick(r, c);
                    } else {
                        cell.onclick = () => onCellClick(r, c);
                    }
                    
                    const piece = board[r][c];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${piece.color}`;
                        if (piece.king) {
                            pieceElement.classList.add('king');
                            const kingSymbol = document.createElement('div');
                            kingSymbol.className = 'king-symbol';
                            kingSymbol.textContent = 'üëë';
                            pieceElement.appendChild(kingSymbol);
                        }
                        
                        if (selectedPiece && selectedPiece.row === r && selectedPiece.col === c) {
                            pieceElement.classList.add('selected');
                        }
                        
                        if (forceCapture && hasForcedCaptures(currentPlayer)) {
                            const pieceCaptures = getCapturesForPiece(r, c, piece);
                            if (pieceCaptures.length > 0) {
                                pieceElement.classList.add('must-capture');
                            }
                        }
                        
                        cell.appendChild(pieceElement);
                    }
                    
                    if (selectedPiece) {
                        const move = validMoves.find(m => 
                            m.to.row === r && m.to.col === c &&
                            m.from.row === selectedPiece.row && m.from.col === selectedPiece.col
                        );
                        if (move) {
                            const dot = document.createElement('div');
                            dot.className = `move-dot ${move.captures && move.captures.length > 0 ? 'capture-dot' : ''}`;
                            cell.appendChild(dot);
                        }
                    }
                    
                    boardElement.appendChild(cell);
                }
            }
        }
        
        function onCellClick(row, col) {
            if (!gameActive) return;
            
            const piece = board[row][col];
            
            if (selectedPiece) {
                const move = validMoves.find(m => 
                    m.to.row === row && m.to.col === col &&
                    m.from.row === selectedPiece.row && m.from.col === selectedPiece.col
                );
                
                if (move) {
                    if (forceCapture && hasForcedCaptures(currentPlayer)) {
                        const allCaptures = getAllCaptures(currentPlayer);
                        if (allCaptures.length > 0 && (!move.captures || move.captures.length === 0)) {
                            applyPenalty(selectedPiece.row, selectedPiece.col);
                            return;
                        }
                    }
                    
                    makeMove(move);
                    return;
                }
            }
            
            if (piece && piece.color === currentPlayer) {
                selectedPiece = { row, col };
                validMoves = getValidMoves(row, col, piece);
                
                if (forceCapture && hasForcedCaptures(currentPlayer)) {
                    const pieceCaptures = getCapturesForPiece(row, col, piece);
                    if (pieceCaptures.length === 0) {
                        selectedPiece = null;
                        validMoves = [];
                        updateStatus("Bu dona bilan olish mumkin emas! Boshqa dona tanlang.");
                        renderBoard();
                        return;
                    }
                    validMoves = pieceCaptures;
                }
                
                renderBoard();
                updateStatus(`${piece.color === 'white' ? 'Oq' : 'Qora'} dona tanlandi. Harakat qilish uchun katakchani tanlang.`);
            } else {
                selectedPiece = null;
                validMoves = [];
                renderBoard();
            }
        }
        
        function getValidMoves(row, col, piece) {
            const moves = [];
            
            const captureMoves = getCapturesForPiece(row, col, piece);
            if (captureMoves.length > 0) {
                return captureMoves;
            }
            
            const dirs = piece.king ? 
                [[1,1], [1,-1], [-1,1], [-1,-1]] :
                (piece.color === 'white' ? [[-1,1], [-1,-1]] : [[1,1], [1,-1]]);
            
            for (const [dr, dc] of dirs) {
                if (piece.king) {
                    let nr = row + dr, nc = col + dc;
                    while (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({
                            from: { row, col },
                            to: { row: nr, col: nc },
                            captures: [],
                            path: [{ row, col }, { row: nr, col: nc }]
                        });
                        nr += dr;
                        nc += dc;
                    }
                } else {
                    const nr = row + dr, nc = col + dc;
                    if (isValid(nr, nc) && !board[nr][nc]) {
                        moves.push({
                            from: { row, col },
                            to: { row: nr, col: nc },
                            captures: [],
                            path: [{ row, col }, { row: nr, col: nc }]
                        });
                    }
                }
            }
            
            return moves;
        }
        
        function getCapturesForPiece(row, col, piece, visited = new Set(), currentPath = []) {
            const moves = [];
            const dirs = piece.king ? 
                [[1,1], [1,-1], [-1,1], [-1,-1]] :
                (piece.color === 'white' ? [[-1,1], [-1,-1]] : [[1,1], [1,-1]]);
            
            for (const [dr, dc] of dirs) {
                const mr = row + dr, mc = col + dc;
                const lr = mr + dr, lc = mc + dc;
                
                if (isValid(mr, mc) && isValid(lr, lc) &&
                    board[mr][mc] && board[mr][mc].color !== piece.color &&
                    !board[lr][lc]) {
                    
                    const captureKey = `${mr},${mc}`;
                    if (visited.has(captureKey)) continue;
                    
                    const newVisited = new Set(visited);
                    newVisited.add(captureKey);
                    
                    const newBoard = simulateMove(board, {
                        from: { row, col },
                        to: { row: lr, col: lc },
                        captures: [{ row: mr, col: mc }]
                    });
                    
                    const newPiece = { ...piece };
                    if (!piece.king && ((piece.color === 'white' && lr === 0) || (piece.color === 'black' && lr === 7))) {
                        newPiece.king = true;
                    }
                    
                    const furtherCaptures = getCapturesForPiece(lr, lc, newPiece, newVisited, [
                        ...currentPath,
                        { row: mr, col: mc }
                    ]);
                    
                    if (furtherCaptures.length > 0) {
                        for (const furtherMove of furtherCaptures) {
                            moves.push({
                                from: { row, col },
                                to: furtherMove.to,
                                captures: [{ row: mr, col: mc }, ...furtherMove.captures],
                                path: [{ row, col }, ...furtherMove.path.slice(1)]
                            });
                        }
                    } else {
                        moves.push({
                            from: { row, col },
                            to: { row: lr, col: lc },
                            captures: [{ row: mr, col: mc }],
                            path: [{ row, col }, { row: lr, col: lc }]
                        });
                    }
                }
            }
            
            return moves;
        }
        
        function getAllCaptures(color) {
            const captures = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color) {
                        captures.push(...getCapturesForPiece(r, c, piece));
                    }
                }
            }
            return captures;
        }
        
        function hasForcedCaptures(color) {
            return getAllCaptures(color).length > 0;
        }
        
        function simulateMove(boardState, move) {
            const newBoard = JSON.parse(JSON.stringify(boardState));
            const piece = newBoard[move.from.row][move.from.col];
            newBoard[move.from.row][move.from.col] = null;
            newBoard[move.to.row][move.to.col] = piece;
            
            if (move.captures) {
                move.captures.forEach(({row, col}) => {
                    newBoard[row][col] = null;
                });
            }
            
            if (!piece.king && ((piece.color === 'white' && move.to.row === 0) ||
                (piece.color === 'black' && move.to.row === 7))) {
                piece.king = true;
            }
            
            return newBoard;
        }
        
        function makeMove(move) {
            loading.classList.add('active');
            
            setTimeout(() => {
                history = history.slice(0, historyIndex + 1);
                const oldBoard = JSON.parse(JSON.stringify(board));
                history.push(oldBoard);
                historyIndex++;
                
                const piece = board[move.from.row][move.from.col];
                board[move.from.row][move.from.col] = null;
                board[move.to.row][move.to.col] = piece;
                
                if (move.captures && move.captures.length > 0) {
                    move.captures.forEach(({row, col}) => {
                        const capturedPiece = board[row][col];
                        if (capturedPiece) {
                            pieceCount[capturedPiece.color]--;
                            if (capturedPiece.king) {
                                kingCount[capturedPiece.color]--;
                            }
                            board[row][col] = null;
                        }
                    });
                }
                
                if (!piece.king) {
                    if ((piece.color === 'white' && move.to.row === 0) ||
                        (piece.color === 'black' && move.to.row === 7)) {
                        piece.king = true;
                        kingCount[piece.color]++;
                    }
                }
                
                moveHistory.push({
                    player: currentPlayer,
                    move: move,
                    pieceCount: { ...pieceCount },
                    kingCount: { ...kingCount }
                });
                
                selectedPiece = null;
                validMoves = [];
                
                if (checkGameOver()) {
                    gameActive = false;
                    showGameOver();
                    loading.classList.remove('active');
                    return;
                }
                
                currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                
                updateUI();
                renderBoard();
                updateStatus();
                
                if (currentPlayer === botColor && autoBot && gameActive) {
                    setTimeout(makeBotMove, 500);
                } else {
                    loading.classList.remove('active');
                }
                
                updateUndoRedoButtons();
            }, 300);
        }
        
        function makeBotMove() {
            if (!gameActive || currentPlayer !== botColor) return;
            
            loading.classList.add('active');
            
            setTimeout(() => {
                const botMove = ai.getBestMove(board, botColor);
                
                if (botMove) {
                    const move = {
                        from: { row: botMove.from[0], col: botMove.from[1] },
                        to: { row: botMove.to[0], col: botMove.to[1] },
                        captures: botMove.captures ? botMove.captures.map(([r, c]) => ({ row: r, col: c })) : [],
                        path: botMove.path.map(([r, c]) => ({ row: r, col: c }))
                    };
                    
                    makeMove(move);
                    
                    botDifficulty.textContent = `${difficulty} - ${['Boshlang\'ich', 'Oson', 'O ªrta', 'Professional', 'Ustun'][Math.min(4, Math.floor(difficulty / 3))]}`;
                    botSearch.textContent = `${ai.stats.depth} daraja, ${ai.stats.time}ms`;
                    botMoves.textContent = `${ai.stats.moves} ta`;
                }
                
                loading.classList.remove('active');
            }, 100);
        }
        
        function applyPenalty(row, col) {
            penaltyCount++;
            board[row][col] = null;
            pieceCount[currentPlayer]--;
            
            penaltyCountElement.textContent = `${penaltyCount}/3`;
            penaltyCountElement.classList.add('penalty-warning');
            
            setTimeout(() => {
                penaltyCountElement.classList.remove('penalty-warning');
            }, 3000);
            
            if (penaltyCount >= 3) {
                gameActive = false;
                showGameOver();
                return;
            }
            
            selectedPiece = null;
            validMoves = [];
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            updateUI();
            renderBoard();
            updateStatus("Jarima! Dona o'chirildi.");
            
            if (currentPlayer === botColor && autoBot) {
                setTimeout(makeBotMove, 1000);
            }
        }
        
        function checkGameOver() {
            const whiteMoves = getAllMovesForColor('white');
            const blackMoves = getAllMovesForColor('black');
            
            if (pieceCount.white === 0 || whiteMoves.length === 0) {
                return 'black';
            }
            
            if (pieceCount.black === 0 || blackMoves.length === 0) {
                return 'white';
            }
            
            return false;
        }
        
        function getAllMovesForColor(color) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color) {
                        moves.push(...getValidMoves(r, c, piece));
                    }
                }
            }
            return moves;
        }
        
        function showGameOver() {
            const winner = checkGameOver();
            const duration = Math.floor((Date.now() - gameStartTime) / 60000);
            
            if (winner === 'white') {
                gameResultText.textContent = playerColor === 'white' ? "üéâ Siz yutdingiz!" : "ü§ñ Bot yutdi!";
                gameResultText.className = "game-over-text win";
            } else {
                gameResultText.textContent = playerColor === 'black' ? "üéâ Siz yutdingiz!" : "ü§ñ Bot yutdi!";
                gameResultText.className = "game-over-text lose";
            }
            
            gameDuration.textContent = duration;
            setTimeout(() => {
                gameOverModal.classList.add('active');
            }, 1000);
        }
        
        function updateUI() {
            currentTurn.textContent = currentPlayer === playerColor ? 
                `Siz (${playerColor === 'white' ? 'oq' : 'qora'})` : 
                `Bot (${botColor === 'white' ? 'oq' : 'qora'})`;
            
            pieceCountElement.textContent = `Oq: ${pieceCount.white} | Qora: ${pieceCount.black}`;
            penaltyCountElement.textContent = `${penaltyCount}/3`;
            
            document.getElementById('player1Indicator').querySelector('span').textContent = 
                `Siz (${playerColor === 'white' ? 'oq' : 'qora'})`;
            document.getElementById('player2Indicator').querySelector('span').textContent = 
                `Bot (${botColor === 'white' ? 'oq' : 'qora'})`;
        }
        
        function updateStatus(message) {
            if (message) {
                statusMessage.textContent = message;
            } else {
                if (currentPlayer === playerColor) {
                    statusMessage.textContent = "Sizning navbatingiz. Dona tanlang...";
                } else {
                    statusMessage.textContent = "Bot o'ylayapti...";
                }
            }
        }
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }
        
        function undoMove() {
            if (historyIndex <= 0 || !gameActive) return;
            
            historyIndex--;
            board = JSON.parse(JSON.stringify(history[historyIndex]));
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            updateUI();
            renderBoard();
            updateStatus("Orqaga qaytdingiz.");
            updateUndoRedoButtons();
        }
        
        function redoMove() {
            if (historyIndex >= history.length - 1 || !gameActive) return;
            
            historyIndex++;
            board = JSON.parse(JSON.stringify(history[historyIndex]));
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            updateUI();
            renderBoard();
            updateStatus("Oldinga qaytdingiz.");
            updateUndoRedoButtons();
        }
        
        function newGame() {
            gameOverModal.classList.remove('active');
            initializeGame();
        }
        
        function isValid(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        // ==================== DASLABKI SOZLAMALAR ====================
        document.getElementById('difficultySlider').addEventListener('input', updateDifficultyLabel);
        document.getElementById('autoBot').addEventListener('change', function() {
            autoBot = this.checked;
        });
        document.getElementById('forceCapture').addEventListener('change', function() {
            forceCapture = this.checked;
        });
        
        updateDifficultyLabel();
        updateColorInfo();
    </script>
</body>
</html>
