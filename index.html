<!DOCTYPE html>
<html lang="uz">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Shashka Pro ‚Äî Impossible Bot Challenge</title>
<style>
:root{--size:min(92vmin,640px);--light:#efe9dd;--dark:#6b8a47;--bg:#f3f5f7}
*{box-sizing:border-box}
body{
    margin:0;
    font-family:Inter,Arial,sans-serif;
    background:linear-gradient(180deg,var(--bg),#eef3f7);
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:18px;
    color:#111;
    min-height:100vh;
    overflow-y:auto;
}

h1{margin:8px 0 14px;font-size:1.15rem}
#boardWrap{padding:18px;border-radius:18px;box-shadow:0 20px 50px rgba(17,24,39,0.18)}
#board{
    width:var(--size);
    height:var(--size);
    display:grid;
    grid-template-columns:repeat(8,1fr);
    grid-template-rows:repeat(8,1fr);
    border-radius:10px;
    overflow:hidden;
    position:relative;
}
.cell{display:flex;align-items:center;justify-content:center;position:relative}
.light{background:linear-gradient(180deg,#f9f7ee,#efe9dd)}
.dark{background:linear-gradient(180deg,#6b8a47,#4b6a34)}
.piece{
    width:78%;
    height:78%;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    font-size:1.02rem;
    cursor:pointer;
    transition:transform .18s ease,box-shadow .18s ease,filter .18s;
    position:relative;
    z-index:2;
    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,0.9),rgba(255,255,255,0.1) 20%),#fff;
    box-shadow:0 8px 20px rgba(0,0,0,0.25),inset 0 -6px 12px rgba(0,0,0,0.05);
    border:1px solid rgba(0,0,0,0.08)
}
.piece.white{
    background:radial-gradient(circle at 28% 28%,rgba(255,255,255,0.95),rgba(255,255,255,0.8) 18%),linear-gradient(180deg,#ffffff,#f2f2f2);
    color:#111
}
.piece.black{
    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,0.12),rgba(255,255,255,0.02) 18%),linear-gradient(180deg,#1b1b1b,#0f0f0f);
    color:#fff
}
.piece.king{
    border:3px solid rgba(245,210,72,0.95);
    box-shadow:0 12px 30px rgba(0,0,0,0.35),0 0 14px rgba(245,210,72,0.08) inset
}
.dot{
    position:absolute;
    width:20%;
    height:20%;
    border-radius:50%;
    background:rgba(255,236,0,0.92);
    z-index:1
}
.selected-outline{
    box-shadow:0 0 0 6px rgba(59,130,246,0.85) inset !important
}
.capture-outline{
    box-shadow:0 0 0 8px rgba(239,68,68,0.9) inset !important
}

/* ==================== YANGI: IMPROVED HARAKAT ANIMATSIYALARI ==================== */
@keyframes smoothMove {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    50% {
        transform: translate(var(--move-x, 0), var(--move-y, 0)) scale(1.1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--move-x, 0), var(--move-y, 0)) scale(1);
        opacity: 1;
    }
}

@keyframes captureJump {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    25% {
        transform: translate(var(--jump-x, 0), var(--jump-y, 0)) scale(1.4);
        opacity: 0.9;
    }
    50% {
        transform: translate(var(--jump-x, 0), var(--jump-y, 0)) scale(1.2);
        opacity: 1;
        filter: drop-shadow(0 0 10px rgba(255,0,0,0.5));
    }
    75% {
        transform: translate(var(--jump-x, 0), var(--jump-y, 0)) scale(1.3);
        opacity: 0.95;
    }
    100% {
        transform: translate(var(--jump-x, 0), var(--jump-y, 0)) scale(1);
        opacity: 1;
    }
}

.moving-piece {
    animation: smoothMove 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards !important;
    z-index: 100 !important;
    pointer-events: none;
}

.capturing-piece {
    animation: captureJump 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards !important;
    z-index: 100 !important;
    pointer-events: none;
}

/* YANGI: Animatsiyalangan o'chirilgan dona */
@keyframes captureDisappear {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    50% {
        transform: scale(1.2);
        opacity: 0.5;
    }
    100% {
        transform: scale(0);
        opacity: 0;
    }
}

.captured-piece {
    animation: captureDisappear 0.5s ease-out forwards !important;
}

@keyframes jumpSelect{0%{transform:scale(1)}50%{transform:scale(1.2)}100%{transform:scale(1)}}
.jumpingSelect{animation:jumpSelect .4s ease forwards}

/* ==================== MODAL TAZZASI ==================== */
.color-modal{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.95);
    display:flex;
    align-items:flex-start;
    justify-content:center;
    z-index:10000;
    flex-direction:column;
    color:white;
    text-align:center;
    overflow-y:auto;
    padding:20px 15px 80px;
}
.color-modal h2{
    margin-bottom:25px;
    font-size:1.8rem;
    line-height:1.2;
    margin-top:20px;
}
.color-options{
    display:flex;
    gap:20px;
    margin:20px 0;
    flex-wrap:wrap;
    justify-content:center;
}
.color-option{
    width:90px;
    height:90px;
    border-radius:50%;
    cursor:pointer;
    transition:transform 0.3s;
    border:4px solid transparent;
    flex-shrink:0;
}
.color-option:hover{
    transform:scale(1.05);
}
.color-option.selected{
    border-color:#3b82f6;
    box-shadow:0 0 20px rgba(59,130,246,0.7);
}
.color-white{
    background:radial-gradient(circle at 30% 30%,#ffffff,#f0f0f0);
    border:2px solid #ddd;
}
.color-black{
    background:radial-gradient(circle at 30% 30%,#222,#000);
    border:2px solid #333;
}
.color-random{
    background:linear-gradient(135deg,#fff 50%,#000 50%);
    border:2px solid #666;
}

/* ==================== BOSHLASH TUGMASI ==================== */
.start-btn{
    margin:30px auto 20px;
    padding:16px 35px;
    font-size:1.1rem;
    background:#3b82f6;
    color:white;
    border:none;
    border-radius:12px;
    cursor:pointer;
    font-weight:bold;
    box-shadow:0 5px 15px rgba(59,130,246,0.4);
    transition:all 0.3s;
    min-width:200px;
    max-width:280px;
    display:block;
}
.start-btn:hover{
    background:#2563eb;
    transform:translateY(-2px);
    box-shadow:0 8px 20px rgba(59,130,246,0.5);
}

/* Qiyinchilik tanlash */
.difficulty-selector{
    margin:20px 0;
    text-align:center;
    width:100%;
    max-width:300px;
}
.difficulty-slider{
    width:100%;
    max-width:300px;
    margin:10px 0;
    opacity:0.5;
    cursor:not-allowed;
}
.difficulty-label{
    font-weight:bold;
    margin-top:10px;
    display:block;
    font-size:1rem;
    color:#ef4444;
}

#gameOver{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.85);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:9999;
    pointer-events:none;
    opacity:0;
    transition:opacity .5s ease;
}
#gameOver.show{
    opacity:1;
    pointer-events:all
}
#gameOver div{
    font-size:3.5rem;
    font-weight:900;
    padding:30px 50px;
    border-radius:20px;
    background:rgba(0,0,0,0.7);
    text-align:center;
    box-shadow:0 0 50px rgba(0,0,0,0.5);
}
.win{color:#10b981!important;text-shadow:0 0 20px rgba(16,185,129,0.5);}
.lose{color:#ef4444!important;text-shadow:0 0 20px rgba(239,68,68,0.5);}
.controls{
    display:flex;
    gap:10px;
    margin-top:12px;
    align-items:center;
    flex-wrap:wrap;
    width:100%;
    max-width:var(--size);
    justify-content:center;
}
button{
    padding:10px 18px;
    border-radius:10px;
    border:0;
    background:#2563eb;
    color:#fff;
    cursor:pointer;
    font-weight:700;
    font-size:0.9rem;
    transition:all 0.2s;
}
button:hover{
    background:#1d4ed8;
    transform:translateY(-2px);
}
.info{
    margin-top:12px;
    padding:14px;
    border-radius:12px;
    background:#fff;
    box-shadow:0 6px 18px rgba(2,6,23,0.06);
    width:90vmin;
    max-width:720px
}
.small{font-size:.95rem;color:#333}
.legend{
    display:flex;
    gap:8px;
    align-items:center;
    margin-top:10px;
    flex-wrap:wrap;
}
.legend .sw{
    width:18px;
    height:18px;
    border-radius:50%;
    border:1px solid rgba(0,0,0,0.06)
}

/* ==================== MOBIL RESPONSIVE ==================== */
@media(max-width:768px){
    body{
        padding:12px;
        min-height:auto;
    }
    
    .color-modal{
        align-items:center;
        justify-content:flex-start;
        padding:30px 15px 100px;
    }
    
    .color-modal h2{
        font-size:1.6rem;
        margin-top:30px;
        margin-bottom:15px;
    }
    
    .modal-content-container{
        display:flex;
        flex-direction:column;
        align-items:center;
        width:100%;
        max-width:100%;
        padding-bottom:20px;
    }
    
    .color-options{
        gap:15px;
        margin:15px 0;
    }
    
    .color-option{
        width:80px;
        height:80px;
    }
    
    .difficulty-selector{
        margin:15px 0;
        max-width:280px;
    }
    
    .difficulty-slider{
        max-width:280px;
    }
    
    .start-btn{
        position:relative;
        bottom:auto;
        left:auto;
        transform:none;
        width:100%;
        max-width:280px;
        margin:25px auto;
        padding:16px;
        font-size:1.1rem;
        z-index:10001;
        box-shadow:0 5px 15px rgba(59,130,246,0.6);
    }
    
    .controls{
        gap:8px;
        padding:0 10px;
    }
    
    button{
        padding:8px 12px;
        font-size:0.85rem;
    }
    
    .info{
        padding:12px;
        margin-top:10px;
    }
    
    #gameOver div{
        font-size:2.5rem;
        padding:20px 30px;
    }
}

@media(max-width:480px){
    h1{font-size:1rem}
    .piece{font-size:.88rem}
    #gameOver div{font-size:2rem}
    
    .color-modal h2{
        font-size:1.4rem;
        margin-top:20px;
    }
    
    .color-option{
        width:70px;
        height:70px;
    }
    
    .start-btn{
        max-width:250px;
        padding:14px;
        font-size:1rem;
    }
    
    .modal-content-container{
        padding-bottom:15px;
    }
}

/* iPhone X and similar */
@media(max-height:700px){
    .color-modal{
        padding:20px 15px 90px;
    }
    
    .color-option{
        width:65px;
        height:65px;
    }
    
    .start-btn{
        margin:20px auto;
    }
}
</style>
</head>
<body>

<!-- Color Selection Modal - FAQRAT BOT BILAN O'YIN -->
<div id="colorModal" class="color-modal">
    <div class="modal-content-container">
        <h2>üéÆ Shashka PRO - Impossible Bot</h2>
        <p style="font-size:1rem;margin-bottom:15px;color:#ccc;max-width:280px;line-height:1.4;">
            O'ynash uchun rang tanlang:
        </p>
        <div class="color-options">
            <div class="color-option color-white selected" onclick="selectColor('white')" title="Oq rang"></div>
            <div class="color-option color-black" onclick="selectColor('black')" title="Qora rang"></div>
            <div class="color-option color-random" onclick="selectColor('random')" title="Tasodifiy rang"></div>
        </div>
        <p style="margin:15px 0;color:#aaa;font-size:0.9rem;max-width:280px;">
            Bot darajasi:
        </p>
        <div class="difficulty-selector">
            <input type="range" min="12" max="12" value="12" class="difficulty-slider" id="difficultySlider" disabled>
            <span class="difficulty-label" id="difficultyLabel">IMPOSSIBLE (12-MAX)</span>
        </div>
        <p id="colorInfo" style="margin:15px 0;color:#3b82f6;font-weight:bold;font-size:1rem;">
            Siz: Oq | Bot: Qora
        </p>
        <p style="margin:10px 0;color:#ef4444;font-size:0.9rem;max-width:280px;line-height:1.4;">
            ‚ö†Ô∏è Eslatma: Bot mukammal o'ynaydi. Yutish juda qiyin!<br>
            ‚ùó Faqat majburiy olish qoidasi ishlaydi
        </p>
    </div>
    <button class="start-btn" onclick="startGame()">üéÆ O'yinni Boshlash</button>
</div>

<div id="mainGame" style="display:none;">
    <h1>Shashka ‚Äî Impossible Bot Challenge</h1>
    <div id="boardWrap"><div id="board"></div></div>
    <div class="controls">
      <button id="newBtn">Yangi o'yin</button>
      <button id="undoBtn">Orqaga</button>
      <button id="redoBtn" disabled>Oldinga</button>
      <label><input id="autoBot" type="checkbox" checked/> Bot avtomatik</label>
      <label><input id="forceCapture" type="checkbox" checked disabled/> Majburiy olish (faqat)</label>
    </div>
    <div class="info">
      <div id="turn" class="small">Navbat: <span id="currentPlayerName">Siz (oq)</span></div>
      <div id="msg" class="small" style="margin-top:6px">Dona tanlang.</div>
      <div id="perf" class="small" style="margin-top:6px;color:#555"></div>
      <div class="legend">
          <div class="sw" style="background:#fff"></div>
          <div class="small" id="player1Label">Siz (oq)</div>
          <div class="sw" style="background:#111"></div>
          <div class="small" id="player2Label">Bot (qora)</div>
      </div>
    </div>
    <div id="gameOver"><div id="resultText"></div></div>
</div>

<script>
/* ==================== O'ZGARUVCHILAR ==================== */
const TIME_LIMIT_MS = 1000; // Muddatni oshirdik
const boardEl = document.getElementById('board'),
      newBtn = document.getElementById('newBtn'),
      undoBtn = document.getElementById('undoBtn'),
      redoBtn = document.getElementById('redoBtn'),
      autoBotCB = document.getElementById('autoBot'),
      forceCaptureCB = document.getElementById('forceCapture'),
      turnEl = document.getElementById('turn'),
      msgEl = document.getElementById('msg'),
      perfEl = document.getElementById('perf'),
      gameOverEl = document.getElementById('gameOver'),
      resultTextEl = document.getElementById('resultText'),
      colorModal = document.getElementById('colorModal'),
      mainGame = document.getElementById('mainGame'),
      difficultySlider = document.getElementById('difficultySlider'),
      difficultyLabel = document.getElementById('difficultyLabel'),
      colorInfoEl = document.getElementById('colorInfo'),
      currentPlayerNameEl = document.getElementById('currentPlayerName'),
      player1LabelEl = document.getElementById('player1Label'),
      player2LabelEl = document.getElementById('player2Label');

let board = [],
    history = [],
    historyIndex = 0,
    selected = null,
    legalMoves = [],
    playerTurn = true,
    autoBot = true,
    playerColor = 'white',
    botColor = 'black',
    difficulty = 12, // Doim maksimal daraja
    forceCapture = true,
    moveHistory = [],
    captures = {white: 0, black: 0},
    historyStack = [],
    futureStack = [];

// ==================== YANGI: PRE-CALCULATED MOVES ====================
const OPENING_BOOK = new Map();
const PERFECT_POSITIONS = new Set();

// Bosh pozitsiyalar uchun optimal yurishlar
function initOpeningBook() {
    // Ochiq o'yin uchun optimal yurishlar
    OPENING_BOOK.set('standard', [
        {from: [5,2], to: [4,3], captures: []},
        {from: [5,4], to: [4,5], captures: []},
        {from: [5,6], to: [4,7], captures: []},
        {from: [2,1], to: [3,0], captures: []},
        {from: [2,3], to: [3,2], captures: []},
        {from: [2,5], to: [3,4], captures: []},
        {from: [2,7], to: [3,6], captures: []}
    ]);
    
    // O'zaro hujum holatlari
    OPENING_BOOK.set('attack', [
        {from: [4,3], to: [3,2], captures: [[3,2]]},
        {from: [4,5], to: [3,6], captures: [[3,6]]},
        {from: [3,2], to: [5,4], captures: [[4,3]]},
        {from: [3,6], to: [5,4], captures: [[4,5]]}
    ]);
}

// Pozitsiya kalitini olish
function getPositionKey(boardState) {
    let key = '';
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const p = boardState[r][c];
            if (p) {
                key += `${p.color[0]}${p.king ? 'K' : 'N'}${r}${c}`;
            }
        }
    }
    return key;
}

// Perfect move topish
function findPerfectMove(boardState, color) {
    const key = getPositionKey(boardState);
    
    // Agar oldindan hisoblangan bo'lsa
    if (PERFECT_POSITIONS.has(key + color[0])) {
        const moves = allMovesFor(boardState, color);
        return getBestPreCalculated(moves, boardState, color);
    }
    
    return null;
}

/* ==================== RANG TANLASH ==================== */
function selectColor(color) {
    if (color === 'random') {
        color = Math.random() > 0.5 ? 'white' : 'black';
        if (color === 'white') {
            playerColor = 'white';
            botColor = 'black';
        } else {
            playerColor = 'black';
            botColor = 'white';
        }
    } else {
        playerColor = color;
        botColor = color === 'white' ? 'black' : 'white';
    }
    
    document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
    event.target.classList.add('selected');
    updateColorInfo();
}

function updateColorInfo() {
    colorInfoEl.textContent = `Siz: ${playerColor === 'white' ? 'Oq' : 'Qora'} | Bot: ${botColor === 'white' ? 'Oq' : 'Qora'}`;
    player1LabelEl.textContent = `Siz (${playerColor === 'white' ? 'oq' : 'qora'})`;
    player2LabelEl.textContent = `Bot (${botColor === 'white' ? 'oq' : 'qora'})`;
}

function startGame() {
    difficulty = 12; // Doim maksimal daraja
    colorModal.style.display = 'none';
    mainGame.style.display = 'block';
    initOpeningBook(); // Opening book ni ishga tushirish
    initBoard();
}

/* ==================== ASOSIY FUNKSIYALAR ==================== */
newBtn.onclick = () => newGame();
undoBtn.onclick = () => undo();
redoBtn.onclick = () => redo();
autoBotCB.onchange = () => {
    autoBot = autoBotCB.checked;
    if (!playerTurn && autoBot) {
        setTimeout(() => botMovePERFECT(), 100);
    }
};

// Majburiy olish faqat va o'chirib bo'lmaydi
forceCaptureCB.checked = true;
forceCaptureCB.disabled = true;

// Qiyinchilik slider ni doim maksimal qilib qo'ydik
difficultySlider.value = 12;
difficultySlider.disabled = true;
difficultyLabel.textContent = 'IMPOSSIBLE (12-MAX)';
difficultyLabel.style.color = '#ef4444';

function initBoard() {
    board = Array.from({length: 8}, () => Array(8).fill(null));
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if ((r + c) % 2 === 1) {
                if (r < 3) board[r][c] = {color: 'black', king: false};
                else if (r > 4) board[r][c] = {color: 'white', king: false};
            }
        }
    }
    history = [cloneBoard(board)];
    historyIndex = 0;
    historyStack = [];
    futureStack = [];
    selected = null;
    legalMoves = [];
    
    // Bot bilan o'ynashda
    playerTurn = playerColor === 'white';
    autoBotCB.disabled = false;
    
    moveHistory = [];
    captures = {white: 0, black: 0};
    updateTurn();
    setPerf('');
    hideGameOver();
    render();
    
    if (!playerTurn && autoBot) {
        setTimeout(() => botMovePERFECT(), 100);
    }
}

function cloneBoard(b) {
    return b.map(row => row.map(cell => cell ? {color: cell.color, king: cell.king} : null));
}

function inBoard(r, c) {
    return r >= 0 && r < 8 && c >= 0 && c < 8;
}

function setMsg(s) {
    msgEl.textContent = s;
}

function setPerf(s) {
    perfEl.textContent = s;
}

function updateTurn() {
    if (playerTurn) {
        currentPlayerNameEl.textContent = `Siz (${playerColor === 'white' ? 'oq' : 'qora'})`;
        turnEl.textContent = "Navbat: Siz";
        turnEl.style.color = '#2563eb';
    } else {
        currentPlayerNameEl.textContent = `Bot (${botColor === 'white' ? 'oq' : 'qora'})`;
        turnEl.textContent = "Navbat: Bot";
        turnEl.style.color = '#ef4444';
    }
}

function showResult(text, isWinForPlayer) {
    resultTextEl.textContent = text;
    resultTextEl.className = isWinForPlayer ? "win" : "lose";
    gameOverEl.classList.add("show");
    setTimeout(() => hideGameOver(), 2500);
}

function hideGameOver() {
    gameOverEl.classList.remove("show");
}

function forwardDirsFor(color) {
    return color === 'white' ? [[-1, 1], [-1, -1]] : [[1, 1], [1, -1]];
}

function continueCaptures(boardState, r, c, visited = new Set()) {
    const p = boardState[r][c];
    if (!p) return [];
    const color = p.color;
    let res = [];
    const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
    
    if (p.king) {
        for (const [dR, dC] of dirs) {
            let sR = r + dR, sC = c + dC;
            while (inBoard(sR, sC) && !boardState[sR][sC]) {
                sR += dR;
                sC += dC;
            }
            if (inBoard(sR, sC) && boardState[sR][sC] && boardState[sR][sC].color !== color) {
                let lR = sR + dR, lC = sC + dC;
                while (inBoard(lR, lC)) {
                    if (boardState[lR][lC]) break;
                    const key = `${sR},${sC}`;
                    if (visited.has(key)) {
                        lR += dR;
                        lC += dC;
                        continue;
                    }
                    const nb = cloneBoard(boardState);
                    nb[lR][lC] = {...nb[r][c], king: true};
                    nb[r][c] = null;
                    nb[sR][sC] = null;
                    const nv = new Set(visited);
                    nv.add(key);
                    const fut = continueCaptures(nb, lR, lC, nv);
                    if (fut.length > 0) {
                        fut.forEach(f => res.push({
                            from: [r, c],
                            to: f.to,
                            path: [[r, c], ...f.path.slice(1)],
                            captures: [[sR, sC], ...f.captures]
                        }));
                    } else {
                        res.push({
                            from: [r, c],
                            to: [lR, lC],
                            path: [[r, c], [lR, lC]],
                            captures: [[sR, sC]]
                        });
                    }
                    lR += dR;
                    lC += dC;
                }
            }
        }
    } else {
        for (const [dR, dC] of dirs) {
            const mR = r + dR, mC = c + dC;
            const lR = r + 2 * dR, lC = c + 2 * dC;
            if (inBoard(lR, lC) && boardState[mR][mC] && 
                boardState[mR][mC].color !== color && !boardState[lR][lC]) {
                const key = `${mR},${mC}`;
                if (visited.has(key)) continue;
                const nb = cloneBoard(boardState);
                nb[lR][lC] = {...nb[r][c]};
                nb[r][c] = null;
                nb[mR][mC] = null;
                if (nb[lR][lC] && !nb[lR][lC].king) {
                    if (nb[lR][lC].color === 'white' && lR === 0) nb[lR][lC].king = true;
                    if (nb[lR][lC].color === 'black' && lR === 7) nb[lR][lC].king = true;
                }
                const nv = new Set(visited);
                nv.add(key);
                const fut = continueCaptures(nb, lR, lC, nv);
                if (fut.length > 0) {
                    fut.forEach(f => res.push({
                        from: [r, c],
                        to: f.to,
                        path: [[r, c], ...f.path.slice(1)],
                        captures: [[mR, mC], ...f.captures]
                    }));
                } else {
                    res.push({
                        from: [r, c],
                        to: [lR, lC],
                        path: [[r, c], [lR, lC]],
                        captures: [[mR, mC]]
                    });
                }
            }
        }
    }
    return res;
}

function movesFrom(boardState, r, c) {
    const p = boardState[r][c];
    if (!p) return [];
    let moves = [];
    
    if (p.king) {
        const dirs = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        for (const [dR, dC] of dirs) {
            let nr = r + dR, nc = c + dC;
            while (inBoard(nr, nc) && !boardState[nr][nc]) {
                moves.push({
                    from: [r, c],
                    to: [nr, nc],
                    path: [[r, c], [nr, nc]],
                    captures: []
                });
                nr += dR;
                nc += dC;
            }
        }
    } else {
        const dirs = forwardDirsFor(p.color);
        for (const [dR, dC] of dirs) {
            const nr = r + dR, nc = c + dC;
            if (inBoard(nr, nc) && !boardState[nr][nc]) {
                moves.push({
                    from: [r, c],
                    to: [nr, nc],
                    path: [[r, c], [nr, nc]],
                    captures: []
                });
            }
        }
    }
    
    const caps = continueCaptures(boardState, r, c);
    return moves.concat(caps);
}

function allMovesFor(boardState, color) {
    let moves = [];
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const p = boardState[r][c];
            if (p && p.color === color) {
                moves = moves.concat(movesFrom(boardState, r, c));
            }
        }
    }
    const caps = moves.filter(m => m.captures && m.captures.length > 0);
    if (forceCapture && caps.length > 0) return caps;
    return moves;
}

function applyMove(boardState, move) {
    const b = cloneBoard(boardState);
    const piece = b[move.from[0]][move.from[1]];
    b[move.from[0]][move.from[1]] = null;
    b[move.to[0]][move.to[1]] = piece;
    
    if (move.captures && move.captures.length > 0) {
        move.captures.forEach(([r, c]) => {
            b[r][c] = null;
            captures[piece.color === 'white' ? 'white' : 'black']++;
        });
    }
    
    if (piece && !piece.king) {
        if (piece.color === 'white' && move.to[0] === 0) piece.king = true;
        if (piece.color === 'black' && move.to[0] === 7) piece.king = true;
    }
    return b;
}

/* ==================== YANGILANGAN ANIMATSIYALI HARAKAT ==================== */
async function animateMove(move) {
    const path = move.path || [move.from, move.to];
    const fromPiece = board[move.from[0]][move.from[1]];
    const isKingBefore = fromPiece && fromPiece.king;
    
    // Olingan donalarni belgilash va animatsiya
    if (move.captures && move.captures.length > 0) {
        for (const [r, c] of move.captures) {
            const capturedCell = boardEl.children[r * 8 + c];
            if (capturedCell) {
                const capturedPiece = capturedCell.querySelector('.piece');
                if (capturedPiece) {
                    capturedPiece.classList.add('captured-piece');
                    await new Promise(r => setTimeout(r, 300));
                }
            }
        }
    }
    
    // Harakat animatsiyasi
    for (let i = 1; i < path.length; i++) {
        const from = path[i-1];
        const to = path[i];
        const fromCell = boardEl.children[from[0] * 8 + from[1]];
        const pieceEl = fromCell.querySelector('.piece');
        
        if (!pieceEl) continue;
        
        const rf = fromCell.getBoundingClientRect();
        const rt = boardEl.children[to[0] * 8 + to[1]].getBoundingClientRect();
        const dx = rt.left - rf.left;
        const dy = rt.top - rf.top;
        
        pieceEl.style.setProperty('--move-x', dx + 'px');
        pieceEl.style.setProperty('--move-y', dy + 'px');
        pieceEl.style.setProperty('--jump-x', dx + 'px');
        pieceEl.style.setProperty('--jump-y', dy + 'px');
        
        if (move.captures && move.captures.length > 0) {
            pieceEl.classList.add('capturing-piece');
            await new Promise(r => setTimeout(r, 800));
            pieceEl.classList.remove('capturing-piece');
        } else {
            pieceEl.classList.add('moving-piece');
            await new Promise(r => setTimeout(r, 600));
            pieceEl.classList.remove('moving-piece');
        }
    }
    
    // Doskani yangilash
    board = applyMove(board, move);
    render();
    
    // Dama animatsiyasi
    const finalCell = boardEl.children[move.to[0] * 8 + move.to[1]];
    const finalPiece = finalCell.querySelector('.piece');
    if (finalPiece && !isKingBefore && board[move.to[0]][move.to[1]].king) {
        finalPiece.style.animation = 'jumpSelect .9s ease-out';
        setTimeout(() => finalPiece.style.animation = '', 1000);
    }
}

/* ==================== ORQAGA/OLDINGA ==================== */
function undo() {
    if (historyIndex <= 0) return;
    futureStack.push(cloneBoard(board));
    historyIndex--;
    board = cloneBoard(history[historyIndex]);
    selected = null;
    legalMoves = [];
    playerTurn = !playerTurn;
    updateUI();
    render();
    setMsg("Orqaga qaytdingiz.");
}

function redo() {
    if (futureStack.length === 0) return;
    historyIndex++;
    if (historyIndex >= history.length) {
        board = futureStack.pop();
        history.push(cloneBoard(board));
    } else {
        board = cloneBoard(history[historyIndex]);
    }
    selected = null;
    legalMoves = [];
    playerTurn = !playerTurn;
    updateUI();
    render();
    setMsg("Oldinga qaytdingiz.");
    
    if (!playerTurn && autoBot) {
        setTimeout(() => botMovePERFECT(), 100);
    }
}

/* ==================== ASOSIY O'YIN FUNKSIYALARI ==================== */
function onCellClick(r, c) {
    // Faqat o'z navbatingizda bosish mumkin
    if (!playerTurn) {
        setMsg("Navbat botda! Kuting...");
        return;
    }
    
    const p = board[r][c];
    
    if (selected) {
        const chosen = legalMoves.find(m => 
            m.to[0] === r && m.to[1] === c && 
            arraysEqual(m.from, selected)
        );
        if (chosen) {
            // MAJBURIY OLISH TEKSHIRISHI
            if (forceCapture && hasForcedCapture()) {
                const pieceCaptures = legalMoves.filter(m => 
                    m.captures && m.captures.length > 0
                );
                if (pieceCaptures.length > 0 && !chosen.captures) {
                    setMsg("Majburiy olish! Boshqa harakat tanlang.");
                    return;
                }
            }
            
            executeMove(chosen);
            return;
        } else {
            selected = null;
            legalMoves = [];
            render();
            return;
        }
    }
    
    if (p && p.color === playerColor) {
        selected = [r, c];
        legalMoves = movesFrom(board, r, c);
        
        // MAJBURIY OLISH TEKSHIRISHI
        if (forceCapture && hasForcedCapture()) {
            const pieceCaptures = legalMoves.filter(m => 
                m.captures && m.captures.length > 0
            );
            if (pieceCaptures.length === 0) {
                setMsg("Bu dona bilan olish mumkin emas! Boshqa dona tanlang.");
                selected = null;
                legalMoves = [];
                return;
            }
        }
        
        render();
        const ce = boardEl.children[r * 8 + c].querySelector('.piece');
        if (ce) {
            ce.classList.add('jumpingSelect');
            setTimeout(() => ce.classList.remove('jumpingSelect'), 400);
        }
    }
}

function hasForcedCapture() {
    const currentColor = playerTurn ? playerColor : botColor;
    const moves = allMovesFor(board, currentColor);
    return moves.some(m => m.captures && m.captures.length > 0);
}

async function executeMove(move) {
    history = history.slice(0, historyIndex + 1);
    const newBoard = applyMove(board, move);
    history.push(cloneBoard(newBoard));
    historyIndex++;
    futureStack = [];
    
    // Animatsiyani ko'rsatish
    await animateMove(move);
    
    if (checkEnd()) {
        endGame();
        return;
    }
    
    playerTurn = !playerTurn;
    updateUI();
    render();
    
    if (!playerTurn && autoBot) {
        setTimeout(() => botMovePERFECT(), 100);
    }
}

function arraysEqual(a, b) {
    if (!a || !b) return false;
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
    }
    return true;
}

// ==================== YANGI: TO'G'RI G'ALABA/MAG'LUBIYAT XABARI ====================
function checkEnd() {
    const wm = allMovesFor(board, 'white');
    const bm = allMovesFor(board, 'black');
    const wp = board.flat().filter(p => p && p.color === 'white').length;
    const bp = board.flat().filter(p => p && p.color === 'black').length;
    
    // Oq yutganda
    if (bp === 0 || bm.length === 0) {
        const winner = playerColor === 'white' ? 'Siz' : 'Bot';
        const isWinForPlayer = playerColor === 'white';
        showResult(`${winner} yutdi!`, isWinForPlayer);
        playerTurn = false;
        return true;
    }
    
    // Qora yutganda
    if (wp === 0 || wm.length === 0) {
        const winner = playerColor === 'black' ? 'Siz' : 'Bot';
        const isWinForPlayer = playerColor === 'black';
        showResult(`${winner} yutdi!`, isWinForPlayer);
        playerTurn = false;
        return true;
    }
    
    return false;
}

function endGame() {
    playerTurn = false;
}

function updateUI() {
    updateTurn();
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = futureStack.length === 0 && historyIndex >= history.length - 1;
}

function render() {
    boardEl.innerHTML = '';
    
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
            cell.addEventListener('click', () => onCellClick(r, c));
            
            if (legalMoves.some(m => m.to[0] === r && m.to[1] === c)) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                cell.appendChild(dot);
            }
            
            const p = board[r][c];
            if (p) {
                const el = document.createElement('div');
                el.className = 'piece ' + (p.color === 'white' ? 'white' : 'black') + (p.king ? ' king' : '');
                el.textContent = p.king ? 'üëë' : '';
                
                if (p.king) {
                    const crown = document.createElement('div');
                    crown.style.position = 'absolute';
                    crown.style.fontSize = '0.8rem';
                    crown.style.top = '8%';
                    crown.style.pointerEvents = 'none';
                    crown.textContent = '‚òÖ';
                    el.appendChild(crown);
                }
                
                // Majburiy olish uchun qizil outline
                if (forceCapture && p.color === playerColor && hasForcedCapture()) {
                    const pieceMoves = movesFrom(board, r, c);
                    if (pieceMoves.some(m => m.captures && m.captures.length > 0)) {
                        el.classList.add('capture-outline');
                    }
                }
                
                if (selected && selected[0] === r && selected[1] === c) {
                    el.classList.add('selected-outline');
                }
                cell.appendChild(el);
            }
            boardEl.appendChild(cell);
        }
    }
    updateTurn();
}

function newGame() {
    initBoard();
}

/* ==================== PERFECT BOT ALGORITMI ==================== */
const transpositionTable = new Map();
const KILLER_MOVES = new Map();

// Pre-calculated eng yaxshi yurishlarni tanlash
function getBestPreCalculated(moves, boardState, color) {
    if (moves.length === 0) return null;
    
    // 1. Olish imkoniyatlari
    const captures = moves.filter(m => m.captures && m.captures.length > 0);
    if (captures.length > 0) {
        // Eng ko'p olish imkoniyati
        captures.sort((a, b) => b.captures.length - a.captures.length);
        return captures[0];
    }
    
    // 2. Dama bo'lish imkoniyati
    const kingingMoves = moves.filter(m => {
        if (color === 'white' && m.to[0] === 0) return true;
        if (color === 'black' && m.to[0] === 7) return true;
        return false;
    });
    if (kingingMoves.length > 0) return kingingMoves[0];
    
    // 3. Markazni nazorat qilish
    const centerMoves = moves.filter(m => {
        const [toR, toC] = m.to;
        return (toC >= 2 && toC <= 5) && (toR >= 2 && toR <= 5);
    });
    if (centerMoves.length > 0) return centerMoves[0];
    
    // 4. Orqa qatorni himoya qilish
    const backRow = color === 'white' ? 7 : 0;
    const backRowMoves = moves.filter(m => m.to[0] === backRow);
    if (backRowMoves.length > 0) return backRowMoves[0];
    
    return moves[0];
}

function evaluatePosition(boardState, color) {
    let score = 0;
    let whitePieces = 0, blackPieces = 0;
    let whiteKings = 0, blackKings = 0;
    
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const p = boardState[r][c];
            if (!p) continue;
            
            const pieceValue = p.king ? 3.0 : 1.0;
            let positionBonus = 0;
            
            // Markaz bonus
            const centerDist = Math.abs(c - 3.5) + Math.abs(r - 3.5);
            positionBonus += (7 - centerDist) * 0.1;
            
            // O'rta qatorlarda bonus
            if (r === 3 || r === 4) positionBonus += 0.2;
            
            // Orqa qator himoyasi
            if ((p.color === 'white' && r === 7) || (p.color === 'black' && r === 0)) {
                positionBonus += 0.3;
            }
            
            // Hujum pozitsiyasi
            if (p.color === 'white' && r < 3) positionBonus += 0.15;
            if (p.color === 'black' && r > 4) positionBonus += 0.15;
            
            if (p.color === color) {
                score += pieceValue + positionBonus;
                if (p.color === 'white') whitePieces++;
                else blackPieces++;
                if (p.king) {
                    score += 0.5; // Dama qo'shimcha bonus
                    if (p.color === 'white') whiteKings++;
                    else blackKings++;
                }
            } else {
                score -= pieceValue + positionBonus;
            }
        }
    }
    
    // Harakatlar soni
    const myMoves = allMovesFor(boardState, color).length;
    const oppMoves = allMovesFor(boardState, color === 'white' ? 'black' : 'white').length;
    score += (myMoves - oppMoves) * 0.05;
    
    // Material ustunlik
    const materialDiff = (color === 'black' ? blackPieces : whitePieces) - 
                         (color === 'white' ? whitePieces : blackPieces);
    score += materialDiff * 0.1;
    
    return score;
}

function perfectAlphaBeta(boardState, depth, alpha, beta, maximizing, startTime, color) {
    if (performance.now() - startTime > TIME_LIMIT_MS) {
        return evaluatePosition(boardState, maximizing ? botColor : playerColor);
    }
    
    if (depth === 0) {
        return evaluatePosition(boardState, maximizing ? botColor : playerColor);
    }
    
    const key = getPositionKey(boardState) + (maximizing ? 'M' : 'm') + depth;
    if (transpositionTable.has(key)) {
        return transpositionTable.get(key);
    }
    
    const currentColor = maximizing ? botColor : playerColor;
    let moves = allMovesFor(boardState, currentColor);
    
    if (moves.length === 0) {
        const score = maximizing ? -10000 : 10000;
        transpositionTable.set(key, score);
        return score;
    }
    
    // Killer moves ni birinchi o'ringa qo'yish
    const killer = KILLER_MOVES.get(getPositionKey(boardState));
    if (killer) {
        moves.sort((a, b) => {
            if (arraysEqual(a.from, killer.from) && arraysEqual(a.to, killer.to)) return -1;
            return 0;
        });
    }
    
    // Pre-sort moves
    moves.sort((a, b) => {
        // 1. Olish imkoniyati
        const aCaptures = a.captures?.length || 0;
        const bCaptures = b.captures?.length || 0;
        if (bCaptures !== aCaptures) return bCaptures - aCaptures;
        
        // 2. Dama bo'lish
        const aKinging = (currentColor === 'white' && a.to[0] === 0) || 
                         (currentColor === 'black' && a.to[0] === 7);
        const bKinging = (currentColor === 'white' && b.to[0] === 0) || 
                         (currentColor === 'black' && b.to[0] === 7);
        if (aKinging && !bKinging) return -1;
        if (!aKinging && bKinging) return 1;
        
        // 3. Position evaluation
        const boardA = applyMove(boardState, a);
        const boardB = applyMove(boardState, b);
        const scoreA = evaluatePosition(boardA, currentColor);
        const scoreB = evaluatePosition(boardB, currentColor);
        return maximizing ? scoreB - scoreA : scoreA - scoreB;
    });
    
    if (maximizing) {
        let maxEval = -Infinity;
        let bestMove = null;
        
        for (const move of moves) {
            if (performance.now() - startTime > TIME_LIMIT_MS) break;
            
            const newBoard = applyMove(boardState, move);
            const evalScore = perfectAlphaBeta(newBoard, depth - 1, alpha, beta, false, startTime, color);
            
            if (evalScore > maxEval) {
                maxEval = evalScore;
                bestMove = move;
            }
            alpha = Math.max(alpha, evalScore);
            if (beta <= alpha) {
                // Killer move ni saqlash
                if (bestMove) {
                    KILLER_MOVES.set(getPositionKey(boardState), bestMove);
                }
                break;
            }
        }
        
        transpositionTable.set(key, maxEval);
        return maxEval;
    } else {
        let minEval = Infinity;
        
        for (const move of moves) {
            if (performance.now() - startTime > TIME_LIMIT_MS) break;
            
            const newBoard = applyMove(boardState, move);
            const evalScore = perfectAlphaBeta(newBoard, depth - 1, alpha, beta, true, startTime, color);
            
            if (evalScore < minEval) {
                minEval = evalScore;
            }
            beta = Math.min(beta, evalScore);
            if (beta <= alpha) break;
        }
        
        transpositionTable.set(key, minEval);
        return minEval;
    }
}

function getPerfectMove(boardState) {
    const startTime = performance.now();
    transpositionTable.clear();
    
    const moves = allMovesFor(boardState, botColor);
    if (moves.length === 0) return null;
    
    // Avval pre-calculated move ni tekshirish
    const perfectMove = findPerfectMove(boardState, botColor);
    if (perfectMove) return perfectMove;
    
    // Alpha-beta search
    let maxDepth = 10; // Maksimal depth
    
    let bestMove = moves[0];
    let bestScore = -Infinity;
    let depth = 1;
    
    while (depth <= maxDepth && performance.now() - startTime < TIME_LIMIT_MS * 0.9) {
        let currentBestMove = moves[0];
        let currentBestScore = -Infinity;
        
        for (const move of moves) {
            if (performance.now() - startTime > TIME_LIMIT_MS * 0.95) break;
            
            const newBoard = applyMove(boardState, move);
            const score = perfectAlphaBeta(newBoard, depth - 1, -Infinity, Infinity, false, startTime, botColor);
            
            if (score > currentBestScore) {
                currentBestScore = score;
                currentBestMove = move;
            }
        }
        
        if (currentBestScore > bestScore || 
            (currentBestScore === bestScore && Math.random() > 0.7)) {
            bestScore = currentBestScore;
            bestMove = currentBestMove;
        }
        
        depth++;
    }
    
    const timeTaken = performance.now() - startTime;
    setPerf(`Bot (${depth-1} daraja, ${timeTaken.toFixed(1)}ms, IMPOSSIBLE)`);
    
    // Perfect pozitsiyani saqlash
    const key = getPositionKey(boardState) + botColor[0];
    PERFECT_POSITIONS.add(key);
    
    return bestMove;
}

async function botMovePERFECT() {
    if (!autoBot) return;
    
    const moves = allMovesFor(board, botColor);
    
    if (moves.length === 0) {
        const isWinForPlayer = playerColor === 'white';
        showResult("Siz yutdingiz!", isWinForPlayer);
        return;
    }
    
    // Avval olish imkoniyatlarini tekshirish
    const captures = moves.filter(m => m.captures && m.captures.length > 0);
    if (captures.length > 0) {
        // Eng ko'p olish imkoniyatini tanlash
        captures.sort((a, b) => {
            // Ko'p olish
            if (b.captures.length !== a.captures.length) {
                return b.captures.length - a.captures.length;
            }
            // Dama olish
            const aKingCaptures = a.captures.filter(([r,c]) => board[r][c]?.king).length;
            const bKingCaptures = b.captures.filter(([r,c]) => board[r][c]?.king).length;
            return bKingCaptures - aKingCaptures;
        });
        
        await executeMove(captures[0]);
        return;
    }
    
    const move = getPerfectMove(board);
    if (move) {
        await executeMove(move);
    }
}

/* ==================== O'YINNI BOSHLASH ==================== */
// Rang tanlashni avtomatik ishga tushirish
selectColor('white');
updateColorInfo();

// Modal oynani yangilash
document.querySelector('.modal-content-container h2').textContent = "üéÆ Shashka - Impossible Bot";
document.querySelector('.modal-content-container p').innerHTML = 
    "Mukammal botga qarshi o'ynang!<br><small style='color:#ef4444'>Yutish juda qiyin!</small>";

</script>
</body>
</html>
