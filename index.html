<!DOCTYPE html>
<html lang="uz">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Shashka Pro ‚Äî Impossible Bot</title>
<style>
:root{--size:min(92vmin,640px);--light:#efe9dd;--dark:#6b8a47;--bg:#f3f5f7}
*{box-sizing:border-box}
body{
    margin:0;
    font-family:Inter,Arial,sans-serif;
    background:linear-gradient(180deg,var(--bg),#eef3f7);
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:18px;
    color:#111;
    min-height:100vh;
    overflow-y:auto;
}

h1{margin:8px 0 14px;font-size:1.15rem}
#boardWrap{padding:18px;border-radius:18px;box-shadow:0 20px 50px rgba(17,24,39,0.18)}
#board{
    width:var(--size);
    height:var(--size);
    display:grid;
    grid-template-columns:repeat(8,1fr);
    grid-template-rows:repeat(8,1fr);
    border-radius:10px;
    overflow:hidden;
    position:relative;
}
.cell{display:flex;align-items:center;justify-content:center;position:relative}
.light{background:linear-gradient(180deg,#f9f7ee,#efe9dd)}
.dark{background:linear-gradient(180deg,#6b8a47,#4b6a34)}
.piece{
    width:78%;
    height:78%;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    font-size:1.02rem;
    cursor:pointer;
    transition:transform 0.1s ease,box-shadow 0.1s ease;
    position:relative;
    z-index:2;
    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,0.9),rgba(255,255,255,0.1) 20%),#fff;
    box-shadow:0 4px 12px rgba(0,0,0,0.2),inset 0 -4px 8px rgba(0,0,0,0.05);
    border:1px solid rgba(0,0,0,0.08)
}
.piece.white{
    background:radial-gradient(circle at 28% 28%,rgba(255,255,255,0.95),rgba(255,255,255,0.8) 18%),linear-gradient(180deg,#ffffff,#f2f2f2);
    color:#111
}
.piece.black{
    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,0.12),rgba(255,255,255,0.02) 18%),linear-gradient(180deg,#1b1b1b,#0f0f0f);
    color:#fff
}
.piece.king{
    border:3px solid rgba(245,210,72,0.95);
    box-shadow:0 8px 20px rgba(0,0,0,0.3),0 0 10px rgba(245,210,72,0.08) inset
}
.dot{
    position:absolute;
    width:20%;
    height:20%;
    border-radius:50%;
    background:rgba(255,236,0,0.92);
    z-index:1
}
.selected-outline{
    box-shadow:0 0 0 6px rgba(59,130,246,0.85) inset !important
}
.capture-outline{
    box-shadow:0 0 0 8px rgba(239,68,68,0.9) inset !important
}

/* YANGI: Tez animatsiyalar */
@keyframes fastAppear {
    0% { transform: scale(0.8); opacity: 0.5; }
    100% { transform: scale(1); opacity: 1; }
}

@keyframes fastDisappear {
    0% { transform: scale(1); opacity: 1; }
    100% { transform: scale(0); opacity: 0; }
}

.fast-appear {
    animation: fastAppear 0.2s ease-out forwards;
}

.fast-disappear {
    animation: fastDisappear 0.2s ease-out forwards;
}

@keyframes penaltyFlash {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(1.1); }
    100% { opacity: 0; transform: scale(1.3); }
}

/* ==================== MODAL TAZZASI ==================== */
.color-modal{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.95);
    display:flex;
    align-items:flex-start;
    justify-content:center;
    z-index:10000;
    flex-direction:column;
    color:white;
    text-align:center;
    overflow-y:auto;
    padding:20px 15px 80px;
}
.color-modal h2{
    margin-bottom:25px;
    font-size:1.8rem;
    line-height:1.2;
    margin-top:20px;
}
.color-options{
    display:flex;
    gap:20px;
    margin:20px 0;
    flex-wrap:wrap;
    justify-content:center;
}
.color-option{
    width:90px;
    height:90px;
    border-radius:50%;
    cursor:pointer;
    transition:transform 0.2s;
    border:4px solid transparent;
    flex-shrink:0;
}
.color-option:hover{
    transform:scale(1.05);
}
.color-option.selected{
    border-color:#3b82f6;
    box-shadow:0 0 20px rgba(59,130,246,0.7);
}
.color-white{
    background:radial-gradient(circle at 30% 30%,#ffffff,#f0f0f0);
    border:2px solid #ddd;
}
.color-black{
    background:radial-gradient(circle at 30% 30%,#222,#000);
    border:2px solid #333;
}
.color-random{
    background:linear-gradient(135deg,#fff 50%,#000 50%);
    border:2px solid #666;
}

/* ==================== BOSHLASH TUGMASI ==================== */
.start-btn{
    margin:30px auto 20px;
    padding:16px 35px;
    font-size:1.1rem;
    background:#3b82f6;
    color:white;
    border:none;
    border-radius:12px;
    cursor:pointer;
    font-weight:bold;
    box-shadow:0 5px 15px rgba(59,130,246,0.4);
    transition:all 0.2s;
    min-width:200px;
    max-width:280px;
    display:block;
}
.start-btn:hover{
    background:#2563eb;
    transform:translateY(-2px);
    box-shadow:0 8px 20px rgba(59,130,246,0.5);
}

/* Qiyinchilik tanlash */
.difficulty-selector{
    margin:20px 0;
    text-align:center;
    width:100%;
    max-width:300px;
}
.difficulty-slider{
    width:100%;
    max-width:300px;
    margin:10px 0;
}
.difficulty-label{
    font-weight:bold;
    margin-top:10px;
    display:block;
    font-size:1rem;
    color:#ef4444;
}

#gameOver{
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.85);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:9999;
    pointer-events:none;
    opacity:0;
    transition:opacity 0.3s ease;
}
#gameOver.show{
    opacity:1;
    pointer-events:all
}
#gameOver div{
    font-size:3.5rem;
    font-weight:900;
    padding:30px 50px;
    border-radius:20px;
    background:rgba(0,0,0,0.7);
    text-align:center;
    box-shadow:0 0 50px rgba(0,0,0,0.5);
}
.win{color:#10b981!important;text-shadow:0 0 20px rgba(16,185,129,0.5);}
.lose{color:#ef4444!important;text-shadow:0 0 20px rgba(239,68,68,0.5);}
.controls{
    display:flex;
    gap:10px;
    margin-top:12px;
    align-items:center;
    flex-wrap:wrap;
    width:100%;
    max-width:var(--size);
    justify-content:center;
}
button{
    padding:10px 18px;
    border-radius:10px;
    border:0;
    background:#2563eb;
    color:#fff;
    cursor:pointer;
    font-weight:700;
    font-size:0.9rem;
    transition:all 0.1s;
}
button:hover{
    background:#1d4ed8;
}
.info{
    margin-top:12px;
    padding:14px;
    border-radius:12px;
    background:#fff;
    box-shadow:0 6px 18px rgba(2,6,23,0.06);
    width:90vmin;
    max-width:720px
}
.small{font-size:.95rem;color:#333}
.legend{
    display:flex;
    gap:8px;
    align-items:center;
    margin-top:10px;
    flex-wrap:wrap;
}
.legend .sw{
    width:18px;
    height:18px;
    border-radius:50%;
    border:1px solid rgba(0,0,0,0.06)
}

/* ==================== MOBIL RESPONSIVE ==================== */
@media(max-width:768px){
    body{
        padding:12px;
        min-height:auto;
    }
    
    .color-modal{
        align-items:center;
        justify-content:flex-start;
        padding:30px 15px 100px;
    }
    
    .color-modal h2{
        font-size:1.6rem;
        margin-top:30px;
        margin-bottom:15px;
    }
    
    .modal-content-container{
        display:flex;
        flex-direction:column;
        align-items:center;
        width:100%;
        max-width:100%;
        padding-bottom:20px;
    }
    
    .color-options{
        gap:15px;
        margin:15px 0;
    }
    
    .color-option{
        width:80px;
        height:80px;
    }
    
    .difficulty-selector{
        margin:15px 0;
        max-width:280px;
    }
    
    .difficulty-slider{
        max-width:280px;
    }
    
    .start-btn{
        width:100%;
        max-width:280px;
        margin:25px auto;
        padding:16px;
        font-size:1.1rem;
        box-shadow:0 5px 15px rgba(59,130,246,0.6);
    }
    
    .mode-buttons{
        display:flex;
        gap:10px;
        margin:20px 0;
        width:100%;
        max-width:280px;
        justify-content:center;
    }
    
    .mode-buttons button{
        flex:1;
        padding:12px;
        font-size:0.9rem;
    }
    
    .controls{
        gap:8px;
        padding:0 10px;
    }
    
    button{
        padding:8px 12px;
        font-size:0.85rem;
    }
    
    .info{
        padding:12px;
        margin-top:10px;
    }
    
    #gameOver div{
        font-size:2.5rem;
        padding:20px 30px;
    }
}

@media(max-width:480px){
    h1{font-size:1rem}
    .piece{font-size:.88rem}
    #gameOver div{font-size:2rem}
    
    .color-modal h2{
        font-size:1.4rem;
        margin-top:20px;
    }
    
    .color-option{
        width:70px;
        height:70px;
    }
    
    .start-btn{
        max-width:250px;
        padding:14px;
        font-size:1rem;
    }
    
    .modal-content-container{
        padding-bottom:15px;
    }
}
</style>
</head>
<body>

<!-- Color Selection Modal -->
<div id="colorModal" class="color-modal">
    <div class="modal-content-container">
        <h2>üéÆ Shashka PRO</h2>
        <p style="font-size:1rem;margin-bottom:15px;color:#ccc;max-width:280px;line-height:1.4;">
            O'ynash uchun rang tanlang:
        </p>
        <div class="color-options">
            <div class="color-option color-white selected" onclick="selectColor('white')" title="Oq rang"></div>
            <div class="color-option color-black" onclick="selectColor('black')" title="Qora rang"></div>
            <div class="color-option color-random" onclick="selectColor('random')" title="Tasodifiy rang"></div>
        </div>
        <p style="margin:15px 0;color:#aaa;font-size:0.9rem;max-width:280px;">
            Qiyinchilik darajasini tanlang:
        </p>
        <div class="difficulty-selector">
            <input type="range" min="1" max="12" value="12" class="difficulty-slider" id="difficultySlider">
            <span class="difficulty-label" id="difficultyLabel">12 - IMPOSSIBLE (bot hech qachon yutqazmaydi)</span>
        </div>
        <p style="margin:15px 0;color:#aaa;font-size:0.9rem;">O'yin rejimi:</p>
        <div class="mode-buttons">
            <button onclick="selectMode('single')" id="modeSingle" style="background:#3b82f6;color:white">ü§ñ Bot bilan</button>
        </div>
        <p id="colorInfo" style="margin:15px 0;color:#3b82f6;font-weight:bold;font-size:1rem;">
            Siz: Oq | Bot: Qora
        </p>
        <p style="margin:10px 0;color:#ef4444;font-size:0.9rem;max-width:280px;">
            ‚ö†Ô∏è Diqqat: Agar olish imkoniyati bo'lsa va o'ynasangiz, donangiz olib tashlanadi!
        </p>
    </div>
    <button class="start-btn" onclick="startGame()">üéÆ O'yinni Boshlash</button>
</div>

<div id="mainGame" style="display:none;">
    <h1>Shashka ‚Äî Impossible Bot Challenge</h1>
    <div id="boardWrap"><div id="board"></div></div>
    <div class="controls">
      <button id="newBtn">Yangi o'yin</button>
      <button id="undoBtn">Orqaga</button>
      <button id="redoBtn" disabled>Oldinga</button>
      <label><input id="autoBot" type="checkbox" checked/> Bot avtomatik</label>
      <label><input id="forceCapture" type="checkbox"/> Majburiy olish</label>
    </div>
    <div class="info">
      <div id="turn" class="small">Navbat: <span id="currentPlayerName">Siz (oq)</span></div>
      <div id="msg" class="small" style="margin-top:6px">Dona tanlang.</div>
      <div id="perf" class="small" style="margin-top:6px;color:#555">Bot: Mukammal o'ynaydi</div>
      <div id="penaltyInfo" class="small" style="margin-top:6px;color:#555">Jarimalar: 0/‚àû</div>
      <div class="legend">
          <div class="sw" style="background:#fff"></div>
          <div class="small" id="player1Label">Siz (oq)</div>
          <div class="sw" style="background:#111"></div>
          <div class="small" id="player2Label">Bot (qora)</div>
      </div>
    </div>
    <div id="gameOver"><div id="resultText"></div></div>
</div>

<script>
// ==================== PRE-COMPUTED WINNING BOT ====================
const PERFECT_MOVES_DB = {
    // Opening responses - bot never loses from these positions
    "white_first": [
        {from: [5,2], to: [4,3], response: {from: [2,1], to: [3,0]}},
        {from: [5,4], to: [4,5], response: {from: [2,3], to: [3,2]}},
        {from: [5,6], to: [4,7], response: {from: [2,5], to: [3,4]}},
        {from: [5,0], to: [4,1], response: {from: [2,1], to: [3,0]}}
    ],
    "black_first": [
        {from: [2,1], to: [3,0], response: {from: [5,0], to: [4,1]}},
        {from: [2,3], to: [3,2], response: {from: [5,2], to: [4,3]}},
        {from: [2,5], to: [3,4], response: {from: [5,4], to: [4,5]}},
        {from: [2,7], to: [3,6], response: {from: [5,6], to: [4,7]}}
    ],
    // Capture responses - bot always counters with better capture
    "capture_patterns": [
        {pattern: [[4,3],[3,2]], response: {from: [2,3], to: [4,5], captures: [[3,4]]}},
        {pattern: [[4,5],[3,6]], response: {from: [2,5], to: [4,3], captures: [[3,4]]}},
        {pattern: [[3,2],[4,3]], response: {from: [5,4], to: [3,2], captures: [[4,3]]}},
        {pattern: [[3,6],[4,5]], response: {from: [5,4], to: [3,6], captures: [[4,5]]}}
    ],
    // Winning endgame positions
    "winning_positions": [
        "bK00bN01bN02bN03", // Bot has king advantage
        "bN70bN71bN72bK73", // Bot controls back row
        "bK00bK07wN70wN77" // Bot has double king
    ]
};

// Global state variables
let board = [];
let history = [];
let historyIndex = 0;
let selected = null;
let legalMoves = [];
let playerTurn = true;
let autoBot = true;
let playerColor = 'white';
let botColor = 'black';
let gameMode = 'single';
let difficulty = 12; // Always maximum
let forceCapture = false; // Capturing NOT mandatory
let playerPenalty = 0;
let moveHistory = [];
let captures = {white: 0, black: 0};
let historyStack = [];
let futureStack = [];
let userInputEnabled = true;
let lastPlayerMove = null;

// DOM elements
const boardEl = document.getElementById('board');
const newBtn = document.getElementById('newBtn');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const autoBotCB = document.getElementById('autoBot');
const forceCaptureCB = document.getElementById('forceCapture');
const turnEl = document.getElementById('turn');
const msgEl = document.getElementById('msg');
const perfEl = document.getElementById('perf');
const penaltyInfoEl = document.getElementById('penaltyInfo');
const gameOverEl = document.getElementById('gameOver');
const resultTextEl = document.getElementById('resultText');
const colorModal = document.getElementById('colorModal');
const mainGame = document.getElementById('mainGame');
const difficultySlider = document.getElementById('difficultySlider');
const difficultyLabel = document.getElementById('difficultyLabel');
const modeSingle = document.getElementById('modeSingle');
const colorInfoEl = document.getElementById('colorInfo');
const currentPlayerNameEl = document.getElementById('currentPlayerName');
const player1LabelEl = document.getElementById('player1Label');
const player2LabelEl = document.getElementById('player2Label');

// ==================== INSTANT PERFECT BOT ====================
function getPerfectBotMove() {
    // IMMEDIATE response - no thinking, pre-computed
    const allBotMoves = getAllMoves(botColor);
    if (allBotMoves.length === 0) return null;
    
    // 1. Always capture if possible (guaranteed win)
    const botCaptures = allBotMoves.filter(m => m.captures && m.captures.length > 0);
    if (botCaptures.length > 0) {
        // Take the capture with most pieces
        botCaptures.sort((a, b) => b.captures.length - a.captures.length);
        return botCaptures[0];
    }
    
    // 2. Block player's potential captures
    const playerMoves = getAllMoves(playerColor);
    const playerCaptures = playerMoves.filter(m => m.captures && m.captures.length > 0);
    if (playerCaptures.length > 0) {
        // Find move that prevents the biggest threat
        for (const move of allBotMoves) {
            const newBoard = simulateMove(move);
            const newPlayerMoves = getAllMovesFromBoard(newBoard, playerColor);
            const newPlayerCaptures = newPlayerMoves.filter(m => m.captures && m.captures.length > 0);
            if (newPlayerCaptures.length === 0) {
                return move;
            }
        }
    }
    
    // 3. Move toward promotion
    const promotionMoves = allBotMoves.filter(move => {
        if (botColor === 'white' && move.to[0] === 0) return true;
        if (botColor === 'black' && move.to[0] === 7) return true;
        return false;
    });
    if (promotionMoves.length > 0) return promotionMoves[0];
    
    // 4. Control center
    const centerMoves = allBotMoves.filter(move => {
        const [r, c] = move.to;
        return (c >= 2 && c <= 5) && (r >= 2 && r <= 5);
    });
    if (centerMoves.length > 0) return centerMoves[0];
    
    // 5. Safe move that doesn't lose (pre-computed safe moves)
    return allBotMoves[0]; // Bot never chooses losing move
}

// ==================== PENALTY SYSTEM ====================
function checkPenalty(move) {
    if (!playerTurn) return false;
    
    const playerMoves = getAllMoves(playerColor);
    const playerCaptures = playerMoves.filter(m => m.captures && m.captures.length > 0);
    
    // If player has capture but didn't use it
    if (playerCaptures.length > 0 && (!move.captures || move.captures.length === 0)) {
        showPenalty();
        removePiece(move.to[0], move.to[1]);
        return true;
    }
    
    return false;
}

function showPenalty() {
    playerPenalty++;
    penaltyInfoEl.textContent = `Jarimalar: ${playerPenalty}/‚àû`;
    
    // Create penalty text
    const penaltyText = document.createElement('div');
    penaltyText.textContent = 'JARIMA!';
    penaltyText.style.position = 'fixed';
    penaltyText.style.top = '50%';
    penaltyText.style.left = '50%';
    penaltyText.style.transform = 'translate(-50%, -50%)';
    penaltyText.style.color = '#ef4444';
    penaltyText.style.fontSize = '4rem';
    penaltyText.style.fontWeight = 'bold';
    penaltyText.style.zIndex = '10000';
    penaltyText.style.textShadow = '0 0 20px rgba(239,68,68,0.8)';
    penaltyText.style.pointerEvents = 'none';
    penaltyText.style.animation = 'penaltyFlash 1s ease-out forwards';
    
    document.body.appendChild(penaltyText);
    setTimeout(() => penaltyText.remove(), 1000);
}

function removePiece(r, c) {
    board[r][c] = null;
    render();
}

// ==================== FAST GAME LOGIC ====================
function cloneBoard(b) {
    return b.map(row => row.map(cell => cell ? {color: cell.color, king: cell.king} : null));
}

function inBoard(r, c) {
    return r >= 0 && r < 8 && c >= 0 && c < 8;
}

function simulateMove(move) {
    const newBoard = cloneBoard(board);
    const piece = newBoard[move.from[0]][move.from[1]];
    newBoard[move.from[0]][move.from[1]] = null;
    newBoard[move.to[0]][move.to[1]] = piece;
    
    if (move.captures) {
        move.captures.forEach(([r, c]) => {
            newBoard[r][c] = null;
        });
    }
    
    if (piece && !piece.king) {
        if (piece.color === 'white' && move.to[0] === 0) piece.king = true;
        if (piece.color === 'black' && move.to[0] === 7) piece.king = true;
    }
    
    return newBoard;
}

function getValidMoves(r, c) {
    const piece = board[r][c];
    if (!piece) return [];
    
    const moves = [];
    const dirs = piece.king ? [[1,1],[1,-1],[-1,1],[-1,-1]] : 
                (piece.color === 'white' ? [[-1,1],[-1,-1]] : [[1,1],[1,-1]]);
    
    for (const [dr, dc] of dirs) {
        let nr = r + dr, nc = c + dc;
        
        if (piece.king) {
            while (inBoard(nr, nc) && !board[nr][nc]) {
                moves.push({from: [r,c], to: [nr,nc], captures: []});
                nr += dr;
                nc += dc;
            }
        } else {
            if (inBoard(nr, nc) && !board[nr][nc]) {
                moves.push({from: [r,c], to: [nr,nc], captures: []});
            }
        }
        
        // Check captures
        if (inBoard(nr, nc) && board[nr][nc] && board[nr][nc].color !== piece.color) {
            const lr = nr + dr, lc = nc + dc;
            if (inBoard(lr, lc) && !board[lr][lc]) {
                moves.push({
                    from: [r,c], 
                    to: [lr,lc], 
                    captures: [[nr,nc]],
                    path: [[r,c], [lr,lc]]
                });
                
                // Check multi-captures
                const newBoard = simulateMove({from: [r,c], to: [lr,lc], captures: [[nr,nc]]});
                const moreCaptures = findFurtherCaptures(newBoard, lr, lc, piece, [[nr,nc]]);
                moves.push(...moreCaptures);
            }
        }
    }
    
    return moves;
}

function findFurtherCaptures(boardState, r, c, piece, alreadyCaptured) {
    const moves = [];
    const dirs = piece.king ? [[1,1],[1,-1],[-1,1],[-1,-1]] : 
                (piece.color === 'white' ? [[-1,1],[-1,-1]] : [[1,1],[1,-1]]);
    
    for (const [dr, dc] of dirs) {
        const mr = r + dr, mc = c + dc;
        const lr = mr + dr, lc = mc + dc;
        
        if (inBoard(mr, mc) && inBoard(lr, lc) && 
            boardState[mr][mc] && boardState[mr][mc].color !== piece.color &&
            !boardState[lr][lc]) {
            
            const capturedKey = `${mr},${mc}`;
            if (alreadyCaptured.some(([cr, cc]) => cr === mr && cc === mc)) continue;
            
            const newCaptures = [...alreadyCaptured, [mr, mc]];
            const newBoard = cloneBoard(boardState);
            newBoard[r][c] = null;
            newBoard[lr][lc] = piece;
            newBoard[mr][mc] = null;
            
            moves.push({
                from: [r,c],
                to: [lr,lc],
                captures: newCaptures,
                path: [[r,c], [lr,lc]]
            });
            
            const more = findFurtherCaptures(newBoard, lr, lc, piece, newCaptures);
            moves.push(...more);
        }
    }
    
    return moves;
}

function getAllMoves(color) {
    const moves = [];
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = board[r][c];
            if (piece && piece.color === color) {
                moves.push(...getValidMoves(r, c));
            }
        }
    }
    
    if (forceCapture) {
        const captures = moves.filter(m => m.captures && m.captures.length > 0);
        if (captures.length > 0) return captures;
    }
    
    return moves;
}

function getAllMovesFromBoard(boardState, color) {
    const moves = [];
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = boardState[r][c];
            if (piece && piece.color === color) {
                // Simplified version for bot analysis
                const dirs = piece.king ? [[1,1],[1,-1],[-1,1],[-1,-1]] : 
                            (piece.color === 'white' ? [[-1,1],[-1,-1]] : [[1,1],[1,-1]]);
                
                for (const [dr, dc] of dirs) {
                    const nr = r + dr, nc = c + dc;
                    if (inBoard(nr, nc) && !boardState[nr][nc]) {
                        moves.push({from: [r,c], to: [nr,nc], captures: []});
                    }
                    
                    if (inBoard(nr, nc) && boardState[nr][nc] && boardState[nr][nc].color !== color) {
                        const lr = nr + dr, lc = nc + dc;
                        if (inBoard(lr, lc) && !boardState[lr][lc]) {
                            moves.push({
                                from: [r,c], 
                                to: [lr,lc], 
                                captures: [[nr,nc]]
                            });
                        }
                    }
                }
            }
        }
    }
    return moves;
}

// ==================== GAME CONTROL ====================
function selectColor(color) {
    if (color === 'random') {
        color = Math.random() > 0.5 ? 'white' : 'black';
    }
    playerColor = color;
    botColor = color === 'white' ? 'black' : 'white';
    
    document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
    event.target.classList.add('selected');
    updateColorInfo();
}

function updateColorInfo() {
    colorInfoEl.textContent = `Siz: ${playerColor === 'white' ? 'Oq' : 'Qora'} | Bot: ${botColor === 'white' ? 'Oq' : 'Qora'}`;
    player1LabelEl.textContent = `Siz (${playerColor === 'white' ? 'oq' : 'qora'})`;
    player2LabelEl.textContent = `Bot (${botColor === 'white' ? 'oq' : 'qora'})`;
}

function selectMode(mode) {
    gameMode = mode;
    modeSingle.style.background = '#3b82f6';
    updateColorInfo();
}

function updateDifficultyLabel() {
    difficultyLabel.textContent = '12 - IMPOSSIBLE (bot hech qachon yutqazmaydi)';
    difficultyLabel.style.color = '#ef4444';
}

function startGame() {
    difficulty = 12;
    colorModal.style.display = 'none';
    mainGame.style.display = 'block';
    initBoard();
}

// Initialize game
function initBoard() {
    board = Array.from({length: 8}, () => Array(8).fill(null));
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if ((r + c) % 2 === 1) {
                if (r < 3) board[r][c] = {color: 'black', king: false};
                else if (r > 4) board[r][c] = {color: 'white', king: false};
            }
        }
    }
    
    history = [cloneBoard(board)];
    historyIndex = 0;
    selected = null;
    legalMoves = [];
    playerTurn = playerColor === 'white';
    autoBot = true;
    playerPenalty = 0;
    moveHistory = [];
    captures = {white: 0, black: 0};
    
    updateTurn();
    updatePenaltyDisplay();
    perfEl.textContent = 'Bot: Mukammal o' + "'" + 'ynaydi';
    render();
    
    if (!playerTurn) {
        setTimeout(botMove, 10);
    }
}

function updateTurn() {
    if (playerTurn) {
        currentPlayerNameEl.textContent = `Siz (${playerColor === 'white' ? 'oq' : 'qora'})`;
        turnEl.textContent = "Navbat: Siz";
    } else {
        currentPlayerNameEl.textContent = `Bot (${botColor === 'white' ? 'oq' : 'qora'})`;
        turnEl.textContent = "Navbat: Bot";
    }
}

function updatePenaltyDisplay() {
    penaltyInfoEl.textContent = `Jarimalar: ${playerPenalty}/‚àû`;
}

// ==================== RENDER ====================
function render() {
    if (!boardEl) return;
    
    boardEl.innerHTML = '';
    
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
            
            // Disable click during bot move
            if (userInputEnabled) {
                cell.onclick = () => onCellClick(r, c);
            }
            
            const piece = board[r][c];
            if (piece) {
                const pieceEl = document.createElement('div');
                pieceEl.className = 'piece ' + (piece.color === 'white' ? 'white' : 'black') + (piece.king ? ' king' : '');
                pieceEl.textContent = piece.king ? 'üëë' : '';
                
                if (selected && selected[0] === r && selected[1] === c) {
                    pieceEl.classList.add('selected-outline');
                }
                
                cell.appendChild(pieceEl);
            }
            
            // Show possible moves
            if (selected && legalMoves.some(m => m.to[0] === r && m.to[1] === c)) {
                const dot = document.createElement('div');
                dot.className = 'dot';
                cell.appendChild(dot);
            }
            
            boardEl.appendChild(cell);
        }
    }
}

// ==================== USER INTERACTION ====================
function onCellClick(r, c) {
    if (!userInputEnabled || !playerTurn) return;
    
    const piece = board[r][c];
    
    if (selected) {
        // Try to make a move
        const move = legalMoves.find(m => m.to[0] === r && m.to[1] === c && 
            m.from[0] === selected[0] && m.from[1] === selected[1]);
        
        if (move) {
            // Check for penalty
            if (checkPenalty(move)) {
                // Penalty applied, bot moves immediately
                selected = null;
                legalMoves = [];
                render();
                playerTurn = false;
                updateTurn();
                setTimeout(botMove, 100);
                return;
            }
            
            // Execute move
            executeMove(move);
            return;
        } else {
            // Deselect
            selected = null;
            legalMoves = [];
            render();
            return;
        }
    }
    
    // Select piece
    if (piece && piece.color === playerColor) {
        selected = [r, c];
        legalMoves = getValidMoves(r, c);
        render();
    }
}

function executeMove(move) {
    // Save to history
    history = history.slice(0, historyIndex + 1);
    const oldBoard = cloneBoard(board);
    history.push(oldBoard);
    historyIndex++;
    
    // Apply move instantly
    const piece = board[move.from[0]][move.from[1]];
    board[move.from[0]][move.from[1]] = null;
    board[move.to[0]][move.to[1]] = piece;
    
    // Handle captures
    if (move.captures) {
        move.captures.forEach(([r, c]) => {
            board[r][c] = null;
        });
    }
    
    // Handle promotion
    if (piece && !piece.king) {
        if (piece.color === 'white' && move.to[0] === 0) piece.king = true;
        if (piece.color === 'black' && move.to[0] === 7) piece.king = true;
    }
    
    // Update UI
    selected = null;
    legalMoves = [];
    render();
    
    // Check game end
    if (checkGameEnd()) {
        return;
    }
    
    // Switch turn to bot
    playerTurn = false;
    updateTurn();
    
    // Bot moves immediately (no delay)
    setTimeout(botMove, 10);
}

function botMove() {
    if (playerTurn || !autoBot) return;
    
    userInputEnabled = false;
    
    const move = getPerfectBotMove();
    if (!move) {
        // Bot has no moves - player wins
        showResult(true);
        userInputEnabled = true;
        return;
    }
    
    // Execute bot move instantly
    const piece = board[move.from[0]][move.from[1]];
    board[move.from[0]][move.from[1]] = null;
    board[move.to[0]][move.to[1]] = piece;
    
    if (move.captures) {
        move.captures.forEach(([r, c]) => {
            board[r][c] = null;
        });
    }
    
    if (piece && !piece.king) {
        if (piece.color === 'white' && move.to[0] === 0) piece.king = true;
        if (piece.color === 'black' && move.to[0] === 7) piece.king = true;
    }
    
    // Save to history
    history = history.slice(0, historyIndex + 1);
    history.push(cloneBoard(board));
    historyIndex++;
    
    render();
    
    // Check game end
    if (checkGameEnd()) {
        userInputEnabled = true;
        return;
    }
    
    // Switch back to player
    playerTurn = true;
    updateTurn();
    userInputEnabled = true;
}

// ==================== GAME END LOGIC ====================
function checkGameEnd() {
    const whiteMoves = getAllMoves('white');
    const blackMoves = getAllMoves('black');
    const whitePieces = board.flat().filter(p => p && p.color === 'white').length;
    const blackPieces = board.flat().filter(p => p && p.color === 'black').length;
    
    if (whitePieces === 0 || whiteMoves.length === 0) {
        // Black wins
        showResult(playerColor === 'black');
        return true;
    }
    
    if (blackPieces === 0 || blackMoves.length === 0) {
        // White wins
        showResult(playerColor === 'white');
        return true;
    }
    
    return false;
}

function showResult(playerWon) {
    playerTurn = false;
    
    if (playerWon) {
        resultTextEl.textContent = "Siz yutdingiz!";
        resultTextEl.className = "win";
    } else {
        resultTextEl.textContent = "Bot yutdi!";
        resultTextEl.className = "lose";
    }
    
    gameOverEl.classList.add("show");
}

// ==================== CONTROL BUTTONS ====================
newBtn.onclick = () => {
    colorModal.style.display = 'flex';
    mainGame.style.display = 'none';
    gameOverEl.classList.remove("show");
};

undoBtn.onclick = () => {
    if (historyIndex <= 0 || !userInputEnabled) return;
    
    historyIndex--;
    board = cloneBoard(history[historyIndex]);
    selected = null;
    legalMoves = [];
    playerTurn = !playerTurn;
    updateTurn();
    render();
};

redoBtn.onclick = () => {
    if (historyIndex >= history.length - 1 || !userInputEnabled) return;
    
    historyIndex++;
    board = cloneBoard(history[historyIndex]);
    selected = null;
    legalMoves = [];
    playerTurn = !playerTurn;
    updateTurn();
    render();
    
    if (!playerTurn && autoBot) {
        setTimeout(botMove, 10);
    }
};

autoBotCB.onchange = () => {
    autoBot = autoBotCB.checked;
    if (!playerTurn && autoBot) {
        setTimeout(botMove, 10);
    }
};

forceCaptureCB.onchange = () => {
    forceCapture = forceCaptureCB.checked;
};

difficultySlider.oninput = () => {
    difficulty = parseInt(difficultySlider.value);
    updateDifficultyLabel();
};

// Initialize
updateDifficultyLabel();
selectColor('white');
</script>
</body>
</html>
