<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shashka PRO - Kombinatsiya AI</title>
    <style>
        /* Asosiy reset va o'zgaruvchilar */
        :root {
            --board-size: min(90vmin, 600px);
            --cell-size: calc(var(--board-size) / 8);
            --light-cell: #f0d9b5;
            --dark-cell: #b58863;
            --piece-white: #ffffff;
            --piece-black: #1a1a1a;
            --piece-white-king: linear-gradient(135deg, #ffffff 0%, #f8f8f8 100%);
            --piece-black-king: linear-gradient(135deg, #2c3e50 0%, #1a1a1a 100%);
            --king-glow: 0 0 15px gold;
            --danger-red: #ff4757;
            --success-green: #2ed573;
            --warning-yellow: #ffa502;
            --primary-blue: #3742fa;
            --ai-thinking: #6c5ce7;
            
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);
            
            --animation-speed-desktop: 200ms;
            --animation-speed-mobile: 120ms;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Game Container */
        .game-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header */
        .game-header {
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .game-header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #ffffff 0%, #cccccc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-header .icon {
            font-size: 2.8rem;
            margin-right: 10px;
        }

        .header-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .difficulty-badge {
            background: linear-gradient(135deg, var(--danger-red) 0%, #ff6b81 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1.1rem;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
        }

        .game-status {
            font-size: 1.1rem;
            color: #ccc;
            font-weight: 500;
        }

        /* Main Game Layout */
        .game-main {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }

        @media (max-width: 1024px) {
            .game-main {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto;
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
                gap: 15px;
            }
            
            .game-header {
                padding: 15px;
            }
            
            .game-header h1 {
                font-size: 2rem;
            }
            
            .difficulty-badge {
                padding: 6px 15px;
                font-size: 1rem;
            }
            
            .game-status {
                font-size: 1rem;
            }
        }

        /* Kichik telefonlar uchun qo'shimcha optimizatsiyalar */
        @media (max-width: 480px) {
            .game-header h1 {
                font-size: 1.5rem;
            }
            
            .player-title h3 {
                font-size: 1rem;
            }
            
            .player-card {
                padding: 15px;
            }
            
            .stat {
                padding: 8px;
            }
            
            .stat-label {
                font-size: 0.75rem;
            }
            
            .stat-value {
                font-size: 1.1rem;
            }
            
            .controls {
                padding: 15px;
                gap: 10px;
            }
            
            .btn {
                padding: 10px 14px;
                font-size: 0.9rem;
            }
        }

        /* Board Container */
        .game-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .board-frame {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-lg);
        }

        .board-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: var(--board-size);
            height: var(--board-size);
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow-md);
        }

        .cell {
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .cell.light {
            background-color: var(--light-cell);
        }

        .cell.dark {
            background-color: var(--dark-cell);
        }

        .cell.dark:hover {
            background-color: color-mix(in srgb, var(--dark-cell) 80%, #000);
        }

        .cell.selected {
            box-shadow: inset 0 0 0 4px var(--success-green);
            z-index: 1;
        }

        .cell.valid-move::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .cell.valid-capture::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            background: rgba(255, 71, 87, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 71, 87, 0.6);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Pieces */
        .piece {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            border-radius: 50%;
            cursor: pointer;
            z-index: 2;
            transition: transform 0.15s ease, left 0.15s ease, top 0.15s ease;
        }

        .piece.moving {
            z-index: 10;
        }

        .piece.white {
            background: var(--piece-white);
            border: 2px solid #d0d0d0;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 -3px 6px rgba(0, 0, 0, 0.1),
                inset 0 3px 6px rgba(255, 255, 255, 0.3);
        }

        .piece.black {
            background: var(--piece-black);
            border: 2px solid #1a1a1a;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 -3px 6px rgba(0, 0, 0, 0.2),
                inset 0 3px 6px rgba(255, 255, 255, 0.1);
        }

        .piece.selected {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 
                0 0 0 4px var(--success-green),
                0 8px 25px rgba(0, 0, 0, 0.3);
            z-index: 3;
        }

        .piece.king {
            border-width: 3px;
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.3),
                inset 0 -4px 8px rgba(0, 0, 0, 0.15),
                inset 0 4px 8px rgba(255, 255, 255, 0.4),
                var(--king-glow);
        }

        .piece.white.king {
            background: var(--piece-white-king);
            border-color: gold;
        }

        .piece.black.king {
            background: var(--piece-black-king);
            border-color: gold;
        }

        .king-symbol {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.3rem;
            color: gold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            filter: drop-shadow(0 0 2px gold);
            z-index: 3;
            pointer-events: none;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 100%;
            max-width: 600px;
        }

        .btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-blue) 0%, #4b4bff 100%);
            border: none;
        }

        .options {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .options label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            color: #ccc;
        }

        .options input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Game Info */
        .game-info {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .player-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .player-card.player-you {
            border-color: rgba(46, 213, 115, 0.3);
        }

        .player-card.player-ai {
            border-color: rgba(255, 71, 87, 0.3);
        }

        .player-title {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .player-title h3 {
            font-size: 1.4rem;
            font-weight: 600;
        }

        .piece-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid;
        }

        .piece-icon.white {
            background: var(--piece-white);
            border-color: #d0d0d0;
        }

        .piece-icon.black {
            background: var(--piece-black);
            border-color: #1a1a1a;
        }

        .player-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .stat-value.max {
            color: var(--danger-red);
        }

        #playerPenalty {
            color: var(--warning-yellow);
            font-weight: 600;
        }

        /* Game State */
        .game-state {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        /* Move history */
        .move-history {
            max-height: 150px;
            font-size: 0.85rem;
        }

        .move-entry {
            padding: 8px 12px;
            margin-bottom: 6px;
            font-size: 0.8rem;
        }

        .current-turn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #turnText {
            font-size: 1.2rem;
            font-weight: 500;
        }

        .turn-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid;
        }

        .turn-indicator.white {
            background: var(--piece-white);
            border-color: #d0d0d0;
            animation: pulse-turn 2s infinite;
        }

        .turn-indicator.black {
            background: var(--piece-black);
            border-color: #1a1a1a;
            animation: pulse-turn 2s infinite;
        }

        .turn-indicator.ai-thinking {
            background: var(--ai-thinking);
            border-color: #8a7fd1;
            animation: pulse-ai 0.5s infinite;
        }

        @keyframes pulse-turn {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes pulse-ai {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .move-history::-webkit-scrollbar {
            width: 6px;
        }

        .move-history::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .move-history::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .move-entry {
            padding: 10px 15px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.95rem;
        }

        .move-entry.ai {
            border-left: 3px solid var(--danger-red);
        }

        .move-entry.player {
            border-left: 3px solid var(--success-green);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            padding: 40px;
            width: 90%;
            max-width: 500px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: var(--shadow-lg);
            text-align: center;
        }

        .modal-content h2 {
            font-size: 2.8rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #ffffff 0%, #cccccc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .result-icon {
            font-size: 5rem;
            margin: 20px 0;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .modal-content p {
            font-size: 1.3rem;
            color: #ccc;
            margin-bottom: 30px;
            line-height: 1.6;
            padding: 0 20px;
        }

        .game-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .game-stats .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .game-stats .stat span:first-child {
            font-size: 1rem;
            color: #aaa;
            font-weight: 500;
        }

        .game-stats .stat span:last-child {
            font-size: 1.8rem;
            font-weight: 700;
            color: white;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        /* Loading AI Indicator */
        .ai-thinking-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            color: var(--ai-thinking);
            font-weight: 500;
        }

        .ai-thinking-indicator .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--ai-thinking);
            animation: bounce-dots 1.4s infinite ease-in-out both;
        }

        .ai-thinking-indicator .dot:nth-child(1) { animation-delay: -0.32s; }
        .ai-thinking-indicator .dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce-dots {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Win/Lose Animation */
        @keyframes confetti {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(1000px) rotate(360deg); opacity: 0; }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: var(--success-green);
            top: -10px;
            opacity: 0;
            z-index: 999;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
            }
            
            .game-header h1 {
                font-size: 2rem;
            }
            
            .board-wrapper {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn {
                justify-content: center;
            }
            
            .player-stats {
                grid-template-columns: 1fr;
            }
            
            .modal-buttons {
                flex-direction: column;
            }
            
            .modal-content h2 {
                font-size: 2.2rem;
            }
            
            .modal-content p {
                font-size: 1.1rem;
            }
        }

        @media (max-width: 480px) {
            :root {
                --board-size: min(95vmin, 400px);
            }
            
            .game-header h1 {
                font-size: 1.8rem;
            }
            
            .player-title h3 {
                font-size: 1.2rem;
            }
            
            .stat-value {
                font-size: 1.3rem;
            }
            
            .modal-content {
                padding: 25px;
            }
            
            .modal-content h2 {
                font-size: 2rem;
            }
            
            .game-stats {
                padding: 15px;
                grid-template-columns: 1fr;
            }
        }

        /* Touch Device Optimizations */
        @media (hover: none) and (pointer: coarse) {
            .cell {
                min-height: 40px;
                min-width: 40px;
            }
            
            .btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            .piece {
                width: 85%;
                height: 85%;
            }
            
            /* Mobile animations - faster */
            .piece.moving {
                transition: transform var(--animation-speed-mobile) ease, 
                          left var(--animation-speed-mobile) ease, 
                          top var(--animation-speed-mobile) ease;
            }
        }

        /* Desktop animations */
        .piece.moving {
            transition: transform var(--animation-speed-desktop) ease, 
                      left var(--animation-speed-desktop) ease, 
                      top var(--animation-speed-desktop) ease;
        }

        /* High Contrast Mode */
        @media (prefers-contrast: high) {
            .piece.white {
                background: white;
                border: 3px solid black;
            }
            
            .piece.black {
                background: black;
                border: 3px solid white;
            }
            
            .cell.light {
                background: white;
            }
            
            .cell.dark {
                background: black;
            }
        }

        /* Reduced Motion */
        @media (prefers-reduced-motion: reduce) {
            .piece, .cell, .btn {
                transition: none;
            }
            
            .cell.valid-capture::after {
                animation: none;
            }
            
            .turn-indicator {
                animation: none;
            }
            
            .piece.moving {
                transition: none;
            }
            
            .result-icon {
                animation: none;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <header class="game-header">
            <h1><span class="icon">‚ôî</span> SHASHKA PRO</h1>
            <div class="header-info">
                <div class="difficulty-badge">KOMBINATSIYA AI</div>
                <div class="game-status" id="gameStatus">O'yin boshlandi</div>
            </div>
        </header>

        <main class="game-main">
            <div class="game-board-container">
                <div class="board-frame">
                    <div class="board-wrapper">
                        <div class="board" id="board">
                            <!-- 8x8 board cells will be generated here -->
                        </div>
                    </div>
                    
                    <!-- AI Thinking Indicator -->
                    <div id="aiThinking" class="ai-thinking-indicator" style="display: none;">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <span>AI harakat qilmoqda...</span>
                    </div>
                </div>

                <div class="controls">
                    <button id="newGame" class="btn">üîÑ Yangi o'yin</button>
                    <button id="undoBtn" class="btn">‚Ü©Ô∏è Orqaga (Ctrl+Z)</button>
                    <button id="hintBtn" class="btn">üí° Maslaha</button>
                    <div class="options">
                        <label>
                            <input type="checkbox" id="soundToggle" checked>
                            <span>üîä Ovoz</span>
                        </label>
                        <label>
                            <input type="checkbox" id="animationToggle" checked>
                            <span>üé¨ Animatsiya</span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="player-card player-you">
                    <div class="player-title">
                        <div class="piece-icon white"></div>
                        <h3>SIZ (OQ)</h3>
                    </div>
                    <div class="player-stats">
                        <div class="stat">
                            <span class="stat-label">Donalar:</span>
                            <span id="playerPieces" class="stat-value">12</span>
                        </div>
                        <div class="stat">
                            <span class="stat-label">Dama:</span>
                            <span id="playerKings" class="stat-value">0</span>
                        </div>
                        <div class="stat">
                            <span class="stat-label">Jarima:</span>
                            <span id="playerPenalty" class="stat-value">0/3</span>
                        </div>
                    </div>
                </div>

                <div class="game-state">
                    <div class="current-turn">
                        <span id="turnText">Sizning navbatingiz</span>
                        <div id="turnIndicator" class="turn-indicator white"></div>
                    </div>
                    <div class="move-history" id="moveHistory">
                        <!-- Move history will be added here -->
                    </div>
                </div>

                <div class="player-card player-ai">
                    <div class="player-title">
                        <div class="piece-icon black"></div>
                        <h3>AI (QORA)</h3>
                    </div>
                    <div class="player-stats">
                        <div class="stat">
                            <span class="stat-label">Donalar:</span>
                            <span id="aiPieces" class="stat-value">12</span>
                        </div>
                        <div class="stat">
                            <span class="stat-label">Dama:</span>
                            <span id="aiKings" class="stat-value">0</span>
                        </div>
                        <div class="stat">
                            <span class="stat-label">Kuch:</span>
                            <span class="stat-value max">KOMBO</span>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <div id="gameOverModal" class="modal">
            <div class="modal-content">
                <h2 id="resultTitle"></h2>
                <div class="result-icon" id="resultIcon"></div>
                <p id="resultMessage"></p>
                <div class="game-stats">
                    <div class="stat">
                        <span>Harakatlar:</span>
                        <span id="totalMoves">0</span>
                    </div>
                    <div class="stat">
                        <span>Olinganlar:</span>
                        <span id="totalCaptures">0</span>
                    </div>
                    <div class="stat">
                        <span>Vaqt:</span>
                        <span id="gameTime">0:00</span>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button id="playAgainBtn" class="btn btn-primary">Yana o'ynash</button>
                    <button id="closeModalBtn" class="btn">Yopish</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SHASHKA GAME ENGINE - REFACTORED VERSION
        // ============================================

        // ==================== GLOBAL RESOURCES ====================
        // Single AudioContext instance for all sound effects
        let globalAudioContext = null;

        // ==================== ASOSIY KONSTANTALAR ====================
        const BOARD_SIZE = 8;
        const PLAYER = {
            HUMAN: 'white',
            AI: 'black'
        };
        const PIECE_TYPE = {
            MAN: 'man',
            KING: 'king'
        };
        const MAX_UNDO_STACK = 50;

        // ==================== GAME STATE KLASSI ====================
        class GameState {
            constructor() {
                this.board = this.createInitialBoard();
                this.currentPlayer = PLAYER.HUMAN;
                this.selectedPiece = null;
                this.validMoves = [];
                this.pieceCount = { [PLAYER.HUMAN]: 12, [PLAYER.AI]: 12 };
                this.kingCount = { [PLAYER.HUMAN]: 0, [PLAYER.AI]: 0 };
                this.penaltyCount = { [PLAYER.HUMAN]: 0, [PLAYER.AI]: 0 };
                this.moveHistory = [];
                this.undoStack = [];
                this.redoStack = [];
                this.totalMoves = 0;
                this.totalCaptures = 0;
                this.gameActive = true;
                this.gameStartTime = Date.now();
                this.userInputEnabled = true;
                this.soundEnabled = true;
                this.animationEnabled = true;
                
                // Animation timing based on device
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                this.animationDuration = this.isMobile ? 120 : 200;
                
                // Qoidalar - DOIM YOQIQ
                this.forceCapture = true;
                this.multiCaptureEnabled = true;
                this.kingFreeMove = true;
            }

            createInitialBoard() {
                const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                
                // Qora donalar (AI) - 1-3 qatorlar
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if ((row + col) % 2 === 1) {
                            board[row][col] = {
                                player: PLAYER.AI,
                                type: PIECE_TYPE.MAN,
                                row,
                                col,
                                id: `ai_${row}_${col}`
                            };
                        }
                    }
                }
                
                // Oq donalar (Human) - 6-8 qatorlar
                for (let row = 5; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if ((row + col) % 2 === 1) {
                            board[row][col] = {
                                player: PLAYER.HUMAN,
                                type: PIECE_TYPE.MAN,
                                row,
                                col,
                                id: `human_${row}_${col}`
                            };
                        }
                    }
                }
                
                return board;
            }

            getPiece(row, col) {
                if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                    return this.board[row][col];
                }
                return null;
            }

            setPiece(row, col, piece) {
                if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE) {
                    this.board[row][col] = piece;
                    if (piece) {
                        piece.row = row;
                        piece.col = col;
                    }
                }
            }

            removePiece(row, col) {
                const piece = this.getPiece(row, col);
                if (piece) {
                    this.pieceCount[piece.player]--;
                    if (piece.type === PIECE_TYPE.KING) {
                        this.kingCount[piece.player]--;
                    }
                    this.board[row][col] = null;
                    return piece;
                }
                return null;
            }

            saveStateForUndo() {
                const state = {
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer,
                    pieceCount: { ...this.pieceCount },
                    kingCount: { ...this.kingCount },
                    penaltyCount: { ...this.penaltyCount },
                    selectedPiece: this.selectedPiece ? { 
                        row: this.selectedPiece.row, 
                        col: this.selectedPiece.col,
                        player: this.selectedPiece.player,
                        type: this.selectedPiece.type,
                        id: this.selectedPiece.id
                    } : null,
                    validMoves: [...this.validMoves],
                    totalMoves: this.totalMoves,
                    totalCaptures: this.totalCaptures,
                    moveHistory: [...this.moveHistory]
                };
                
                this.undoStack.push(state);
                if (this.undoStack.length > MAX_UNDO_STACK) {
                    this.undoStack.shift();
                }
                this.redoStack = [];
            }

            /**
             * Undo the last move - restores the previous game state
             * @returns {boolean} True if undo was successful
             */
            undo() {
                if (this.undoStack.length === 0) {
                    return false;
                }
                
                // Save current state to redo stack
                const currentState = {
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer,
                    pieceCount: { ...this.pieceCount },
                    kingCount: { ...this.kingCount },
                    penaltyCount: { ...this.penaltyCount },
                    selectedPiece: this.selectedPiece ? { 
                        row: this.selectedPiece.row, 
                        col: this.selectedPiece.col,
                        player: this.selectedPiece.player,
                        type: this.selectedPiece.type,
                        id: this.selectedPiece.id
                    } : null,
                    validMoves: [...this.validMoves],
                    totalMoves: this.totalMoves,
                    totalCaptures: this.totalCaptures,
                    moveHistory: [...this.moveHistory]
                };
                this.redoStack.push(currentState);
                
                // Restore previous state
                const prevState = this.undoStack.pop();
                this.board = prevState.board;
                this.currentPlayer = prevState.currentPlayer;
                this.pieceCount = prevState.pieceCount;
                this.kingCount = prevState.kingCount;
                this.penaltyCount = prevState.penaltyCount;
                this.totalMoves = prevState.totalMoves;
                this.totalCaptures = prevState.totalCaptures;
                this.moveHistory = prevState.moveHistory;
                
                // Restore selected piece
                if (prevState.selectedPiece) {
                    const piece = this.getPiece(prevState.selectedPiece.row, prevState.selectedPiece.col);
                    this.selectedPiece = piece;
                } else {
                    this.selectedPiece = null;
                }
                
                // Restore valid moves
                this.validMoves = prevState.validMoves;
                
                // Restore piece positions in the board objects
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            piece.row = row;
                            piece.col = col;
                        }
                    }
                }
                
                return true;
            }

            /**
             * Redo the previously undone move
             * @returns {boolean} True if redo was successful
             */
            redo() {
                if (this.redoStack.length === 0) return false;
                
                // Save current state to undo stack
                const currentState = {
                    board: JSON.parse(JSON.stringify(this.board)),
                    currentPlayer: this.currentPlayer,
                    pieceCount: { ...this.pieceCount },
                    kingCount: { ...this.kingCount },
                    penaltyCount: { ...this.penaltyCount },
                    selectedPiece: this.selectedPiece ? { 
                        row: this.selectedPiece.row, 
                        col: this.selectedPiece.col,
                        player: this.selectedPiece.player,
                        type: this.selectedPiece.type,
                        id: this.selectedPiece.id
                    } : null,
                    validMoves: [...this.validMoves],
                    totalMoves: this.totalMoves,
                    totalCaptures: this.totalCaptures,
                    moveHistory: [...this.moveHistory]
                };
                this.undoStack.push(currentState);
                
                // Restore redo state
                const nextState = this.redoStack.pop();
                this.board = nextState.board;
                this.currentPlayer = nextState.currentPlayer;
                this.pieceCount = nextState.pieceCount;
                this.kingCount = nextState.kingCount;
                this.penaltyCount = nextState.penaltyCount;
                this.totalMoves = nextState.totalMoves;
                this.totalCaptures = nextState.totalCaptures;
                this.moveHistory = nextState.moveHistory;
                
                // Restore selected piece
                if (nextState.selectedPiece) {
                    const piece = this.getPiece(nextState.selectedPiece.row, nextState.selectedPiece.col);
                    this.selectedPiece = piece;
                } else {
                    this.selectedPiece = null;
                }
                
                // Restore valid moves
                this.validMoves = nextState.validMoves;
                
                // Restore piece positions
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = this.board[row][col];
                        if (piece) {
                            piece.row = row;
                            piece.col = col;
                        }
                    }
                }
                
                return true;
            }

            switchPlayer() {
                this.currentPlayer = this.currentPlayer === PLAYER.HUMAN ? PLAYER.AI : PLAYER.HUMAN;
            }

            reset() {
                this.board = this.createInitialBoard();
                this.currentPlayer = PLAYER.HUMAN;
                this.selectedPiece = null;
                this.validMoves = [];
                this.pieceCount = { [PLAYER.HUMAN]: 12, [PLAYER.AI]: 12 };
                this.kingCount = { [PLAYER.HUMAN]: 0, [PLAYER.AI]: 0 };
                this.penaltyCount = { [PLAYER.HUMAN]: 0, [PLAYER.AI]: 0 };
                this.moveHistory = [];
                this.undoStack = [];
                this.redoStack = [];
                this.totalMoves = 0;
                this.totalCaptures = 0;
                this.gameActive = true;
                this.gameStartTime = Date.now();
                this.userInputEnabled = true;
            }
        }

        // ==================== MOVE CALCULATOR ====================
        class MoveCalculator {
            constructor(gameState) {
                this.gameState = gameState;
            }

            getAllValidMoves(player) {
                const moves = [];
                let maxCaptures = 0;
                const allCaptureMoves = [];
                
                // Avval barcha olish harakatlarini topish
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = this.gameState.getPiece(row, col);
                        if (piece && piece.player === player) {
                            const captures = this.getCaptureMovesForPiece(piece);
                            if (captures.length > 0) {
                                allCaptureMoves.push(...captures);
                                captures.forEach(move => {
                                    if (move.captures.length > maxCaptures) {
                                        maxCaptures = move.captures.length;
                                    }
                                });
                            }
                        }
                    }
                }
                
                // Agar olish harakati bo'lsa, faqat olish harakatlarini qaytarish
                if (this.gameState.forceCapture && allCaptureMoves.length > 0) {
                    return allCaptureMoves.filter(move => move.captures.length === maxCaptures);
                }
                
                // Agar olish bo'lmasa, oddiy harakatlar
                if (allCaptureMoves.length === 0) {
                    for (let row = 0; row < BOARD_SIZE; row++) {
                        for (let col = 0; col < BOARD_SIZE; col++) {
                            const piece = this.gameState.getPiece(row, col);
                            if (piece && piece.player === player) {
                                const simpleMoves = this.getSimpleMovesForPiece(piece);
                                moves.push(...simpleMoves);
                            }
                        }
                    }
                }
                
                return moves;
            }

            getCaptureMovesForPiece(piece, visited = new Set()) {
                const moves = [];
                const directions = this.getDirections(piece);
                
                for (const [dr, dc] of directions) {
                    if (piece.type === PIECE_TYPE.KING) {
                        let currentRow = piece.row + dr;
                        let currentCol = piece.col + dc;
                        
                        while (this.isValidPosition(currentRow, currentCol)) {
                            const targetPiece = this.gameState.getPiece(currentRow, currentCol);
                            
                            if (targetPiece) {
                                if (targetPiece.player !== piece.player && !visited.has(`${currentRow},${currentCol}`)) {
                                    let landingRow = currentRow + dr;
                                    let landingCol = currentCol + dc;
                                    
                                    while (this.isValidPosition(landingRow, landingCol)) {
                                        if (!this.gameState.getPiece(landingRow, landingCol)) {
                                            const newVisited = new Set(visited);
                                            newVisited.add(`${currentRow},${currentCol}`);
                                            
                                            const captureMove = {
                                                from: { row: piece.row, col: piece.col },
                                                to: { row: landingRow, col: landingCol },
                                                piece: piece,
                                                captures: [{ 
                                                    row: currentRow, 
                                                    col: currentCol, 
                                                    piece: targetPiece 
                                                }],
                                                isCapture: true
                                            };
                                            
                                            const simulatedPiece = { ...piece, row: landingRow, col: landingCol };
                                            const furtherCaptures = this.getCaptureMovesForPiece(simulatedPiece, newVisited);
                                            
                                            if (furtherCaptures.length > 0) {
                                                furtherCaptures.forEach(furtherMove => {
                                                    moves.push({
                                                        from: { row: piece.row, col: piece.col },
                                                        to: furtherMove.to,
                                                        piece: piece,
                                                        captures: [...captureMove.captures, ...furtherMove.captures],
                                                        isCapture: true
                                                    });
                                                });
                                            } else {
                                                moves.push(captureMove);
                                            }
                                        } else {
                                            break;
                                        }
                                        landingRow += dr;
                                        landingCol += dc;
                                    }
                                    break;
                                } else {
                                    break;
                                }
                            }
                            currentRow += dr;
                            currentCol += dc;
                        }
                    } else {
                        const captureRow = piece.row + dr;
                        const captureCol = piece.col + dc;
                        const landingRow = captureRow + dr;
                        const landingCol = captureCol + dc;
                        
                        if (this.canCapture(piece, captureRow, captureCol, landingRow, landingCol, visited)) {
                            const newVisited = new Set(visited);
                            newVisited.add(`${captureRow},${captureCol}`);
                            
                            const targetPiece = this.gameState.getPiece(captureRow, captureCol);
                            
                            const captureMove = {
                                from: { row: piece.row, col: piece.col },
                                to: { row: landingRow, col: landingCol },
                                piece: piece,
                                captures: [{ 
                                    row: captureRow, 
                                    col: captureCol, 
                                    piece: targetPiece 
                                }],
                                isCapture: true
                            };
                            
                            const simulatedPiece = { ...piece, row: landingRow, col: landingCol };
                            const furtherCaptures = this.getCaptureMovesForPiece(simulatedPiece, newVisited);
                            
                            if (furtherCaptures.length > 0) {
                                furtherCaptures.forEach(furtherMove => {
                                    moves.push({
                                        from: { row: piece.row, col: piece.col },
                                        to: furtherMove.to,
                                        piece: piece,
                                        captures: [...captureMove.captures, ...furtherMove.captures],
                                        isCapture: true
                                    });
                                });
                            } else {
                                moves.push(captureMove);
                            }
                        }
                    }
                }
                
                return moves;
            }

            getSimpleMovesForPiece(piece) {
                const moves = [];
                const directions = this.getDirections(piece);
                
                for (const [dr, dc] of directions) {
                    if (piece.type === PIECE_TYPE.KING) {
                        let newRow = piece.row + dr;
                        let newCol = piece.col + dc;
                        
                        while (this.isValidPosition(newRow, newCol)) {
                            if (!this.gameState.getPiece(newRow, newCol)) {
                                moves.push({
                                    from: { row: piece.row, col: piece.col },
                                    to: { row: newRow, col: newCol },
                                    piece: piece,
                                    captures: [],
                                    isCapture: false
                                });
                            } else {
                                break;
                            }
                            newRow += dr;
                            newCol += dc;
                        }
                    } else {
                        const newRow = piece.row + dr;
                        const newCol = piece.col + dc;
                        
                        if (this.isValidPosition(newRow, newCol) && !this.gameState.getPiece(newRow, newCol)) {
                            moves.push({
                                from: { row: piece.row, col: piece.col },
                                to: { row: newRow, col: newCol },
                                piece: piece,
                                captures: [],
                                isCapture: false
                            });
                        }
                    }
                }
                
                return moves;
            }

            getDirections(piece) {
                if (piece.type === PIECE_TYPE.KING) {
                    return [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                } else if (piece.player === PLAYER.HUMAN) {
                    return [[-1, 1], [-1, -1]];
                } else {
                    return [[1, 1], [1, -1]];
                }
            }

            canCapture(piece, captureRow, captureCol, landingRow, landingCol, visited) {
                if (!this.isValidPosition(captureRow, captureCol) || 
                    !this.isValidPosition(landingRow, landingCol)) {
                    return false;
                }
                
                const captureKey = `${captureRow},${captureCol}`;
                if (visited.has(captureKey)) {
                    return false;
                }
                
                const capturedPiece = this.gameState.getPiece(captureRow, captureCol);
                if (!capturedPiece || capturedPiece.player === piece.player) {
                    return false;
                }
                
                if (this.gameState.getPiece(landingRow, landingCol)) {
                    return false;
                }
                
                return true;
            }

            isValidPosition(row, col) {
                return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
            }

            getAllCaptureMoves(player) {
                const captures = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const piece = this.gameState.getPiece(row, col);
                        if (piece && piece.player === player) {
                            const pieceCaptures = this.getCaptureMovesForPiece(piece);
                            captures.push(...pieceCaptures);
                        }
                    }
                }
                return captures;
            }
        }

        // ==================== KOMBINATSIYA ASOSIDA BOT ====================
        class UnbeatableAI {
            constructor() {
                this.combinations = this.createPredefinedCombinations();
                this.currentCombinationIndex = 0;
                this.moveSequence = [];
                this.currentMoveIndex = 0;
                this.initializeMoveSequence();
            }

            createPredefinedCombinations() {
                return [
                    {
                        name: "Markaz nazorati",
                        moves: [
                            { from: { row: 2, col: 3 }, to: { row: 3, col: 2 }, captures: [] },
                            { from: { row: 2, col: 5 }, to: { row: 3, col: 4 }, captures: [] },
                            { from: { row: 1, col: 2 }, to: { row: 2, col: 1 }, captures: [] },
                            { from: { row: 1, col: 4 }, to: { row: 2, col: 3 }, captures: [] }
                        ]
                    },
                    {
                        name: "Chap qanot hujumi",
                        moves: [
                            { from: { row: 2, col: 1 }, to: { row: 3, col: 0 }, captures: [] },
                            { from: { row: 1, col: 0 }, to: { row: 2, col: 1 }, captures: [] },
                            { from: { row: 2, col: 3 }, to: { row: 3, col: 2 }, captures: [] },
                            { from: { row: 0, col: 1 }, to: { row: 1, col: 0 }, captures: [] }
                        ]
                    },
                    {
                        name: "O'ng qanot hujumi",
                        moves: [
                            { from: { row: 2, col: 5 }, to: { row: 3, col: 6 }, captures: [] },
                            { from: { row: 1, col: 6 }, to: { row: 2, col: 5 }, captures: [] },
                            { from: { row: 2, col: 7 }, to: { row: 3, col: 6 }, captures: [] },
                            { from: { row: 0, col: 7 }, to: { row: 1, col: 6 }, captures: [] }
                        ]
                    },
                    {
                        name: "Fork hujumi",
                        moves: [
                            { from: { row: 2, col: 3 }, to: { row: 4, col: 1 }, captures: [{row: 3, col: 2}] },
                            { from: { row: 1, col: 2 }, to: { row: 2, col: 3 }, captures: [] },
                            { from: { row: 2, col: 5 }, to: { row: 4, col: 3 }, captures: [{row: 3, col: 4}] },
                            { from: { row: 0, col: 3 }, to: { row: 1, col: 4 }, captures: [] }
                        ]
                    },
                    {
                        name: "Pin kombinatsiyasi",
                        moves: [
                            { from: { row: 2, col: 1 }, to: { row: 3, col: 2 }, captures: [] },
                            { from: { row: 1, col: 0 }, to: { row: 2, col: 1 }, captures: [] },
                            { from: { row: 2, col: 3 }, to: { row: 3, col: 4 }, captures: [] },
                            { from: { row: 0, col: 1 }, to: { row: 2, col: 3 }, captures: [{row: 1, col: 2}] }
                        ]
                    },
                    {
                        name: "Sacrifice kombinatsiyasi",
                        moves: [
                            { from: { row: 2, col: 3 }, to: { row: 3, col: 2 }, captures: [] },
                            { from: { row: 1, col: 4 }, to: { row: 2, col: 3 }, captures: [] },
                            { from: { row: 2, col: 5 }, to: { row: 4, col: 3 }, captures: [{row: 3, col: 4}] },
                            { from: { row: 0, col: 5 }, to: { row: 1, col: 4 }, captures: [] }
                        ]
                    },
                    {
                        name: "Ikkilama hujum",
                        moves: [
                            { from: { row: 2, col: 3 }, to: { row: 4, col: 1 }, captures: [{row: 3, col: 2}] },
                            { from: { row: 4, col: 1 }, to: { row: 6, col: 3 }, captures: [{row: 5, col: 2}] },
                            { from: { row: 1, col: 0 }, to: { row: 2, col: 1 }, captures: [] },
                            { from: { row: 0, col: 1 }, to: { row: 1, col: 0 }, captures: [] }
                        ]
                    },
                    {
                        name: "Dama yaratish",
                        moves: [
                            { from: { row: 5, col: 2 }, to: { row: 6, col: 3 }, captures: [] },
                            { from: { row: 5, col: 4 }, to: { row: 6, col: 5 }, captures: [] },
                            { from: { row: 4, col: 3 }, to: { row: 5, col: 4 }, captures: [] },
                            { from: { row: 3, col: 2 }, to: { row: 5, col: 4 }, captures: [{row: 4, col: 3}] },
                            { from: { row: 6, col: 5 }, to: { row: 7, col: 4 }, captures: [] }
                        ]
                    },
                    {
                        name: "Diagonal hujum",
                        moves: [
                            { from: { row: 2, col: 3 }, to: { row: 3, col: 4 }, captures: [] },
                            { from: { row: 1, col: 4 }, to: { row: 2, col: 5 }, captures: [] },
                            { from: { row: 2, col: 7 }, to: { row: 3, col: 6 }, captures: [] },
                            { from: { row: 0, col: 5 }, to: { row: 1, col: 6 }, captures: [] }
                        ]
                    },
                    {
                        name: "Himoyaviy tizim",
                        moves: [
                            { from: { row: 1, col: 2 }, to: { row: 2, col: 3 }, captures: [] },
                            { from: { row: 1, col: 6 }, to: { row: 2, col: 5 }, captures: [] },
                            { from: { row: 0, col: 3 }, to: { row: 1, col: 2 }, captures: [] },
                            { from: { row: 0, col: 5 }, to: { row: 1, col: 4 }, captures: [] }
                        ]
                    }
                ];
            }

            initializeMoveSequence() {
                this.moveSequence = [];
                this.combinations.forEach(combo => {
                    this.moveSequence.push(...combo.moves);
                });
            }

            getBestMove(gameState, moveCalculator) {
                const allMoves = moveCalculator.getAllValidMoves(PLAYER.AI);
                if (allMoves.length === 0) return null;
                if (allMoves.length === 1) return allMoves[0];

                if (this.currentMoveIndex < this.moveSequence.length) {
                    const predefinedMove = this.moveSequence[this.currentMoveIndex];
                    
                    const move = this.findMatchingMove(predefinedMove, allMoves, gameState);
                    if (move) {
                        this.currentMoveIndex++;
                        return move;
                    } else {
                        this.currentMoveIndex++;
                        return this.getBestMove(gameState, moveCalculator);
                    }
                } else {
                    this.currentMoveIndex = 0;
                    return this.getBestMove(gameState, moveCalculator);
                }
            }

            findMatchingMove(predefinedMove, allMoves, gameState) {
                for (const move of allMoves) {
                    if (move.from.row === predefinedMove.from.row &&
                        move.from.col === predefinedMove.from.col &&
                        move.to.row === predefinedMove.to.row &&
                        move.to.col === predefinedMove.to.col) {
                        
                        if (predefinedMove.captures && predefinedMove.captures.length > 0) {
                            if (move.isCapture && move.captures.length >= predefinedMove.captures.length) {
                                return move;
                            }
                        } else if (!move.isCapture) {
                            return move;
                        }
                    }
                }

                let bestAlternative = null;
                let bestScore = -Infinity;

                for (const move of allMoves) {
                    const fromDistance = Math.abs(move.from.row - predefinedMove.from.row) +
                                       Math.abs(move.from.col - predefinedMove.from.col);
                    const toDistance = Math.abs(move.to.row - predefinedMove.to.row) +
                                     Math.abs(move.to.col - predefinedMove.to.col);
                    
                    if (fromDistance <= 2 && toDistance <= 3) {
                        const score = this.calculateMovePriority(move, gameState);
                        
                        if (predefinedMove.captures && predefinedMove.captures.length > 0 && move.isCapture) {
                            if (move.captures.length >= predefinedMove.captures.length) {
                                return move;
                            }
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestAlternative = move;
                        }
                    }
                }

                return bestAlternative;
            }

            calculateMovePriority(move, gameState) {
                let priority = 0;
                
                if (move.isCapture) {
                    priority += 1000 + (move.captures.length * 500);
                    
                    for (const capture of move.captures) {
                        const capturedPiece = gameState.getPiece(capture.row, capture.col);
                        if (capturedPiece && capturedPiece.type === PIECE_TYPE.KING) {
                            priority += 800;
                        }
                    }
                }
                
                if (move.piece.type === PIECE_TYPE.MAN && move.to.row === 7) {
                    priority += 1200;
                }
                
                const centerDistance = Math.abs(move.to.row - 3.5) + Math.abs(move.to.col - 3.5);
                priority += (8 - centerDistance) * 50;
                
                if (move.to.row === 0 && move.piece.type === PIECE_TYPE.MAN) {
                    priority += 100;
                }
                
                if (this.isSafePosition(move.to.row, move.to.col, gameState, move.piece.player)) {
                    priority += 150;
                }
                
                const humanPieceDistance = this.calculateDistanceToHumanPieces(move.to.row, move.to.col, gameState);
                priority += (8 - humanPieceDistance) * 20;
                
                return priority;
            }

            calculateDistanceToHumanPieces(row, col, gameState) {
                let minDistance = Infinity;
                
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const piece = gameState.getPiece(r, c);
                        if (piece && piece.player === PLAYER.HUMAN) {
                            const distance = Math.abs(row - r) + Math.abs(col - c);
                            if (distance < minDistance) {
                                minDistance = distance;
                            }
                        }
                    }
                }
                
                return minDistance === Infinity ? 8 : minDistance;
            }

            isSafePosition(row, col, gameState, player) {
                const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
                const opponent = player === PLAYER.HUMAN ? PLAYER.AI : PLAYER.HUMAN;
                
                for (const [dr, dc] of directions) {
                    const attackRow = row + dr;
                    const attackCol = col + dc;
                    const landingRow = row - dr;
                    const landingCol = col - dc;
                    
                    if (this.isValidPosition(attackRow, attackCol) && 
                        this.isValidPosition(landingRow, landingCol)) {
                        const attacker = gameState.getPiece(attackRow, attackCol);
                        const landing = gameState.getPiece(landingRow, landingCol);
                        
                        if (attacker && attacker.player === opponent && !landing) {
                            if (attacker.type === PIECE_TYPE.MAN) {
                                if ((attacker.player === PLAYER.HUMAN && dr === 1) ||
                                    (attacker.player === PLAYER.AI && dr === -1)) {
                                    return false;
                                }
                            } else {
                                return false;
                            }
                        }
                    }
                }
                
                return true;
            }

            isValidPosition(row, col) {
                return row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE;
            }
        }

        // ==================== SOUND MANAGER ====================
        class SoundManager {
            constructor() {
                this.audioContext = null;
                this.soundEnabled = true;
                this.initialize();
            }

            initialize() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log("AudioContext not supported:", e);
                }
            }

            playSound(soundName) {
                if (!this.soundEnabled || !this.audioContext) return;

                try {
                    if (soundName === 'move') {
                        this.playTone(440, 100, 'sine', 0.1);
                    } else if (soundName === 'capture') {
                        this.playTone(220, 200, 'square', 0.2);
                    } else if (soundName === 'king') {
                        this.playSequence([523.25, 659.25, 783.99], 100, 'sine', 0.15);
                    } else if (soundName === 'penalty') {
                        this.playTone(110, 300, 'sawtooth', 0.25);
                    } else if (soundName === 'win') {
                        setTimeout(() => this.playTone(440, 300, 'sine', 0.1), 0);
                        setTimeout(() => this.playTone(550, 300, 'sine', 0.1), 150);
                        setTimeout(() => this.playTone(660, 300, 'sine', 0.1), 300);
                    } else if (soundName === 'lose') {
                        this.playTone(220, 500, 'sawtooth', 0.15);
                    }
                } catch (e) {
                    console.log("Audio error:", e);
                }
            }

            playTone(frequency, duration, type, volume) {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                gainNode.gain.value = volume;
                
                oscillator.start();
                setTimeout(() => {
                    oscillator.stop();
                }, duration);
            }

            playSequence(frequencies, duration, type, volume) {
                let delay = 0;
                frequencies.forEach(freq => {
                    setTimeout(() => {
                        this.playTone(freq, duration, type, volume);
                    }, delay);
                    delay += duration / 3;
                });
            }

            toggleSound(enabled) {
                this.soundEnabled = enabled;
            }
        }

        // ==================== GAME ENGINE ====================
        class ShashkaGame {
            constructor() {
                this.gameState = new GameState();
                this.moveCalculator = new MoveCalculator(this.gameState);
                this.aiEngine = new UnbeatableAI();
                this.soundManager = new SoundManager();
                this.ui = new GameUI(this);
                this.isAnimating = false;
                this.isUndoing = false;
                
                this.initialize();
                this.bindKeyboardShortcuts();
            }

            initialize() {
                this.ui.initialize();
                this.updateUI();
                this.ui.showMessage("O'yin boshlandi. Sizning navbatingiz.");
            }

            bindKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.undoMove();
                    }
                    if (e.ctrlKey && e.key === 'y') {
                        e.preventDefault();
                        this.redoMove();
                    }
                });
            }

            handleCellClick(row, col) {
                if (!this.gameState.gameActive || !this.gameState.userInputEnabled || this.isAnimating || this.isUndoing) {
                    return;
                }

                if (this.gameState.currentPlayer !== PLAYER.HUMAN) {
                    return;
                }

                const clickedPiece = this.gameState.getPiece(row, col);
                
                if (this.gameState.selectedPiece) {
                    const move = this.gameState.validMoves.find(m => 
                        m.to.row === row && m.to.col === col &&
                        m.from.row === this.gameState.selectedPiece.row && 
                        m.from.col === this.gameState.selectedPiece.col
                    );

                    if (move) {
                        this.executeMove(move);
                        return;
                    }
                }

                if (clickedPiece && clickedPiece.player === PLAYER.HUMAN) {
                    this.selectPiece(clickedPiece);
                } else {
                    this.clearSelection();
                }
            }

            selectPiece(piece) {
                this.clearSelection();
                
                this.gameState.selectedPiece = piece;
                this.gameState.validMoves = this.moveCalculator.getAllValidMoves(PLAYER.HUMAN)
                    .filter(move => 
                        move.from.row === piece.row && 
                        move.from.col === piece.col
                    );
                
                if (this.gameState.validMoves.length === 0) {
                    this.ui.showMessage("Bu dona bilan harakat qilish mumkin emas.");
                    this.clearSelection();
                    return;
                }
                
                const hasCaptureMoves = this.gameState.validMoves.some(m => m.isCapture);
                const allCaptures = this.moveCalculator.getAllCaptureMoves(PLAYER.HUMAN);
                
                if (this.gameState.forceCapture && allCaptures.length > 0 && !hasCaptureMoves) {
                    this.applyPenalty(piece.row, piece.col);
                    return;
                }
                
                this.ui.highlightPiece(piece);
                this.ui.highlightValidMoves(this.gameState.validMoves);
                
                const square = this.getSquareNotation(piece.row, piece.col);
                this.ui.showMessage(`${square} donasi tanlandi.`);
            }

            applyPenalty(row, col) {
                const piece = this.gameState.getPiece(row, col);
                if (!piece) return;
                
                this.gameState.penaltyCount[piece.player]++;
                
                this.gameState.removePiece(row, col);
                
                this.soundManager.playSound('penalty');
                
                this.ui.showMessage(`JARIMA! ${this.getSquareNotation(row, col)} donasi o'chirildi.`);
                
                if (this.gameState.penaltyCount[piece.player] >= 3) {
                    this.endGame(false);
                    return;
                }
                
                this.clearSelection();
                this.switchTurn();
                this.updateUI();
                
                if (this.gameState.currentPlayer === PLAYER.AI) {
                    this.makeAIMove();
                }
            }

            async executeMove(move) {
                this.isAnimating = true;
                this.gameState.userInputEnabled = false;
                
                this.gameState.saveStateForUndo();
                
                this.gameState.moveHistory.push({
                    move: move,
                    boardState: JSON.parse(JSON.stringify(this.gameState.board))
                });
                
                if (move.captures && move.captures.length > 0) {
                    await this.animateCaptures(move.captures);
                    move.captures.forEach(capture => {
                        this.gameState.removePiece(capture.row, capture.col);
                        this.gameState.totalCaptures++;
                    });
                    
                    this.soundManager.playSound('capture');
                } else {
                    this.soundManager.playSound('move');
                }
                
                await this.animatePieceMove(move);
                
                const piece = move.piece;
                this.gameState.setPiece(move.from.row, move.from.col, null);
                this.gameState.setPiece(move.to.row, move.to.col, piece);
                piece.row = move.to.row;
                piece.col = move.to.col;
                
                if (piece.type === PIECE_TYPE.MAN) {
                    if ((piece.player === PLAYER.HUMAN && move.to.row === 0) ||
                        (piece.player === PLAYER.AI && move.to.row === BOARD_SIZE - 1)) {
                        piece.type = PIECE_TYPE.KING;
                        this.gameState.kingCount[piece.player]++;
                        
                        this.soundManager.playSound('king');
                        
                        await this.animateKingPromotion(piece);
                    }
                }
                
                this.gameState.totalMoves++;
                
                this.clearSelection();
                this.updateUI();
                
                this.addMoveToHistory(move);
                
                const winner = this.checkGameOver();
                if (winner !== null) {
                    this.endGame(winner === PLAYER.HUMAN);
                    this.isAnimating = false;
                    return;
                }
                
                this.switchTurn();
                
                this.isAnimating = false;
                this.gameState.userInputEnabled = true;
                
                if (this.gameState.currentPlayer === PLAYER.AI) {
                    await this.makeAIMove();
                }
            }

            /**
             * Animates piece captures with proper timing for mobile/desktop
             */
            animateCaptures(captures) {
                return new Promise(resolve => {
                    if (!this.gameState.animationEnabled) {
                        resolve();
                        return;
                    }
                    
                    const animationDuration = this.gameState.isMobile ? 120 : 200;
                    let completed = 0;
                    captures.forEach(capture => {
                        const cell = this.ui.getCellElement(capture.row, capture.col);
                        const piece = cell.querySelector('.piece');
                        if (piece) {
                            piece.style.transition = `transform ${animationDuration}ms ease, opacity ${animationDuration}ms ease`;
                            piece.style.transform = 'translate(-50%, -50%) scale(0)';
                            piece.style.opacity = '0';
                            
                            setTimeout(() => {
                                completed++;
                                if (completed === captures.length) {
                                    resolve();
                                }
                            }, animationDuration);
                        } else {
                            completed++;
                            if (completed === captures.length) {
                                resolve();
                            }
                        }
                    });
                });
            }

            /**
             * Animates piece movement with optimized timing for mobile devices
             */
            animatePieceMove(move) {
                return new Promise(resolve => {
                    if (!this.gameState.animationEnabled) {
                        resolve();
                        return;
                    }
                    
                    const fromCell = this.ui.getCellElement(move.from.row, move.from.col);
                    const pieceElement = fromCell.querySelector('.piece');
                    
                    if (pieceElement) {
                        pieceElement.classList.add('moving');
                        
                        const fromRect = fromCell.getBoundingClientRect();
                        const toCell = this.ui.getCellElement(move.to.row, move.to.col);
                        const toRect = toCell.getBoundingClientRect();
                        
                        const dx = toRect.left - fromRect.left;
                        const dy = toRect.top - fromRect.top;
                        
                        pieceElement.style.left = `calc(50% + ${dx}px)`;
                        pieceElement.style.top = `calc(50% + ${dy}px)`;
                        
                        setTimeout(() => {
                            pieceElement.classList.remove('moving');
                            pieceElement.style.left = '50%';
                            pieceElement.style.top = '50%';
                            resolve();
                        }, this.gameState.animationDuration);
                    } else {
                        resolve();
                    }
                });
            }

            animateKingPromotion(piece) {
                return new Promise(resolve => {
                    if (!this.gameState.animationEnabled) {
                        resolve();
                        return;
                    }
                    
                    const cell = this.ui.getCellElement(piece.row, piece.col);
                    const pieceElement = cell.querySelector('.piece');
                    
                    if (pieceElement) {
                        pieceElement.classList.add('king');
                        
                        for (let i = 0; i < 10; i++) {
                            setTimeout(() => {
                                const particle = document.createElement('div');
                                particle.style.position = 'absolute';
                                particle.style.width = '4px';
                                particle.style.height = '4px';
                                particle.style.background = 'gold';
                                particle.style.borderRadius = '50%';
                                particle.style.left = '50%';
                                particle.style.top = '50%';
                                particle.style.transform = `translate(${Math.random() * 40 - 20}px, ${Math.random() * 40 - 20}px)`;
                                pieceElement.appendChild(particle);
                                
                                setTimeout(() => {
                                    particle.remove();
                                }, 600);
                            }, i * 30);
                        }
                        
                        setTimeout(() => {
                            const kingSymbol = document.createElement('div');
                            kingSymbol.className = 'king-symbol';
                            kingSymbol.textContent = '‚ôî';
                            pieceElement.appendChild(kingSymbol);
                            resolve();
                        }, 500);
                    } else {
                        resolve();
                    }
                });
            }

            async makeAIMove() {
                if (!this.gameState.gameActive || this.gameState.currentPlayer !== PLAYER.AI) {
                    return;
                }
                
                this.gameState.userInputEnabled = false;
                this.isAnimating = true;
                
                this.ui.showAIThinking(true);
                this.ui.showMessage("AI kombinatsiya qilmoqda...");
                
                await new Promise(resolve => setTimeout(resolve, 150));
                
                const aiMove = this.aiEngine.getBestMove(this.gameState, this.moveCalculator);
                
                this.ui.showAIThinking(false);
                
                if (!aiMove) {
                    this.endGame(true);
                    return;
                }
                
                await this.executeMove(aiMove);
                
                this.gameState.userInputEnabled = true;
                this.isAnimating = false;
            }

            switchTurn() {
                this.gameState.switchPlayer();
                const turnText = this.gameState.currentPlayer === PLAYER.HUMAN 
                    ? "Sizning navbatingiz" 
                    : "AI kombinatsiya qilmoqda";
                this.ui.showMessage(turnText);
                this.ui.updateTurnIndicator(this.gameState.currentPlayer);
            }

            checkGameOver() {
                const humanMoves = this.moveCalculator.getAllValidMoves(PLAYER.HUMAN);
                if (humanMoves.length === 0) {
                    return PLAYER.AI;
                }
                
                const aiMoves = this.moveCalculator.getAllValidMoves(PLAYER.AI);
                if (aiMoves.length === 0) {
                    return PLAYER.HUMAN;
                }
                
                if (this.gameState.pieceCount[PLAYER.HUMAN] === 0) {
                    return PLAYER.AI;
                }
                
                if (this.gameState.pieceCount[PLAYER.AI] === 0) {
                    return PLAYER.HUMAN;
                }
                
                if (this.gameState.penaltyCount[PLAYER.HUMAN] >= 3) {
                    return PLAYER.AI;
                }
                
                if (this.gameState.penaltyCount[PLAYER.AI] >= 3) {
                    return PLAYER.HUMAN;
                }
                
                return null;
            }

            endGame(isHumanWinner) {
                this.gameState.gameActive = false;
                this.gameState.userInputEnabled = false;
                this.isAnimating = false;
                
                const duration = Math.floor((Date.now() - this.gameState.gameStartTime) / 1000);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                
                if (isHumanWinner && this.gameState.animationEnabled) {
                    this.createConfetti();
                }
                
                this.ui.showGameOver(
                    isHumanWinner, 
                    minutes, 
                    seconds, 
                    this.gameState.totalMoves, 
                    this.gameState.totalCaptures
                );
                
                if (isHumanWinner) {
                    this.soundManager.playSound('win');
                } else {
                    this.soundManager.playSound('lose');
                }
            }

            createConfetti() {
                const colors = ['#2ed573', '#3742fa', '#ffa502', '#ff4757', '#6c5ce7'];
                const confettiCount = 100;
                
                for (let i = 0; i < confettiCount; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + 'vw';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.width = Math.random() * 10 + 5 + 'px';
                    confetti.style.height = Math.random() * 10 + 5 + 'px';
                    confetti.style.opacity = Math.random() * 0.5 + 0.5;
                    
                    document.body.appendChild(confetti);
                    
                    const animation = confetti.animate([
                        { transform: `translateY(-100px) rotate(0deg)`, opacity: 1 },
                        { transform: `translateY(${window.innerHeight}px) rotate(${Math.random() * 360}deg)`, opacity: 0 }
                    ], {
                        duration: Math.random() * 3000 + 2000,
                        easing: 'cubic-bezier(0.215, 0.610, 0.355, 1)'
                    });
                    
                    animation.onfinish = () => confetti.remove();
                }
            }

            /**
             * Undo the last move for human or AI
             * This properly restores board state, piece counts, and move history
             */
            undoMove() {
                if (this.gameState.undoStack.length === 0 || this.isAnimating || this.isUndoing) {
                    this.ui.showMessage("Orqaga olish mumkin emas.");
                    return;
                }
                
                this.isUndoing = true;
                
                const success = this.gameState.undo();
                if (success) {
                    this.clearSelection();
                    
                    this.updateUI();
                    this.ui.showMessage("Harakat bekor qilindi.");
                    
                    // Update move history display
                    this.ui.clearMoveHistory();
                    this.gameState.moveHistory.forEach(moveEntry => {
                        this.addMoveToHistory(moveEntry.move);
                    });
                    
                    // Switch turn if AI was playing
                    if (this.gameState.currentPlayer === PLAYER.AI) {
                        this.gameState.switchPlayer();
                        this.ui.updateTurnIndicator(this.gameState.currentPlayer);
                        this.ui.showMessage("Sizning navbatingiz.");
                    }
                }
                
                this.isUndoing = false;
            }

            redoMove() {
                if (this.gameState.redoStack.length === 0 || this.isAnimating) {
                    return;
                }
                
                const success = this.gameState.redo();
                if (success) {
                    this.clearSelection();
                    this.updateUI();
                    this.ui.showMessage("Harakat qayta tiklandi.");
                }
            }

            getHint() {
                if (!this.gameState.gameActive || this.gameState.currentPlayer !== PLAYER.HUMAN || this.isAnimating) {
                    this.ui.showMessage("Hozir maslaha berish mumkin emas.");
                    return;
                }
                
                const humanMoves = this.moveCalculator.getAllValidMoves(PLAYER.HUMAN);
                if (humanMoves.length === 0) {
                    this.ui.showMessage("Harakat qilish imkoni yo'q.");
                    return;
                }
                
                let bestMove = null;
                let bestScore = -Infinity;
                
                for (const move of humanMoves) {
                    let score = 0;
                    
                    if (move.isCapture) {
                        score += move.captures.length * 150;
                        
                        for (const capture of move.captures) {
                            const capturedPiece = this.gameState.getPiece(capture.row, capture.col);
                            if (capturedPiece && capturedPiece.type === PIECE_TYPE.KING) {
                                score += 400;
                            }
                        }
                    }
                    
                    if (move.piece.type === PIECE_TYPE.MAN && move.to.row === 0) {
                        score += 600;
                    }
                    
                    const centerDistance = Math.abs(move.to.row - 3.5) + Math.abs(move.to.col - 3.5);
                    score += (8 - centerDistance) * 30;
                    
                    if (this.aiEngine.isSafePosition(move.to.row, move.to.col, this.gameState, PLAYER.HUMAN)) {
                        score += 50;
                    }
                    
                    const aiMoves = this.moveCalculator.getAllValidMoves(PLAYER.AI);
                    let isUnderAttack = false;
                    
                    for (const aiMove of aiMoves) {
                        if (aiMove.isCapture) {
                            for (const capture of aiMove.captures) {
                                if (capture.row === move.to.row && capture.col === move.to.col) {
                                    isUnderAttack = true;
                                    break;
                                }
                            }
                        }
                        if (isUnderAttack) break;
                    }
                    
                    if (!isUnderAttack) {
                        score += 100;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                
                if (bestMove) {
                    this.ui.showHint(bestMove);
                    
                    let strengthText = "";
                    if (bestScore > 800) strengthText = " (Ajoyib harakat!)";
                    else if (bestScore > 500) strengthText = " (Yaxshi harakat)";
                    else if (bestScore > 200) strengthText = " (Oddiy harakat)";
                    
                    const fromNotation = this.getSquareNotation(bestMove.from.row, bestMove.from.col);
                    const toNotation = this.getSquareNotation(bestMove.to.row, bestMove.to.col);
                    this.ui.showMessage(`Maslaha: ${fromNotation} ‚Üí ${toNotation}${strengthText}`);
                }
            }

            getSquareNotation(row, col) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                return files[col] + ranks[row];
            }

            clearSelection() {
                this.gameState.selectedPiece = null;
                this.gameState.validMoves = [];
                this.ui.clearHighlights();
            }

            addMoveToHistory(move) {
                const fromNotation = this.getSquareNotation(move.from.row, move.from.col);
                const toNotation = this.getSquareNotation(move.to.row, move.to.col);
                const player = move.piece.player === PLAYER.HUMAN ? "Oq" : "Qora";
                const captureText = move.captures.length > 0 ? ` (x${move.captures.length})` : "";
                const kingText = move.piece.type === PIECE_TYPE.KING ? " ‚ôî" : "";
                const isPromotion = move.piece.type === PIECE_TYPE.MAN && 
                    ((move.piece.player === PLAYER.HUMAN && move.to.row === 0) ||
                     (move.piece.player === PLAYER.AI && move.to.row === BOARD_SIZE - 1));
                const promotionText = isPromotion ? " ‚Üí Dama!" : "";
                
                const entry = {
                    text: `${player}: ${fromNotation} ‚Üí ${toNotation}${captureText}${kingText}${promotionText}`,
                    player: move.piece.player
                };
                
                this.ui.addMoveToHistory(entry);
            }

            updateUI() {
                this.ui.updateBoard(this.gameState.board);
                this.ui.updatePlayerInfo(
                    this.gameState.pieceCount[PLAYER.HUMAN],
                    this.gameState.kingCount[PLAYER.HUMAN],
                    this.gameState.pieceCount[PLAYER.AI],
                    this.gameState.kingCount[PLAYER.AI],
                    this.gameState.penaltyCount[PLAYER.HUMAN]
                );
                this.ui.updateTurnIndicator(this.gameState.currentPlayer);
            }

            newGame() {
                this.gameState.reset();
                this.aiEngine = new UnbeatableAI();
                this.ui.hideGameOverModal();
                this.initialize();
            }

            toggleSound() {
                this.gameState.soundEnabled = !this.gameState.soundEnabled;
                this.soundManager.toggleSound(this.gameState.soundEnabled);
                this.ui.updateSoundButton(this.gameState.soundEnabled);
            }

            toggleAnimation() {
                this.gameState.animationEnabled = !this.gameState.animationEnabled;
                this.ui.updateAnimationButton(this.gameState.animationEnabled);
            }
        }

        // ==================== UI MANAGER ====================
        class GameUI {
            constructor(game) {
                this.game = game;
                this.elements = {};
            }

            initialize() {
                this.cacheElements();
                this.bindEvents();
                this.createBoard();
                this.updateSoundButton(this.game.gameState.soundEnabled);
                this.updateAnimationButton(this.game.gameState.animationEnabled);
            }

            cacheElements() {
                this.elements = {
                    board: document.getElementById('board'),
                    gameStatus: document.getElementById('gameStatus'),
                    playerPieces: document.getElementById('playerPieces'),
                    playerKings: document.getElementById('playerKings'),
                    playerPenalty: document.getElementById('playerPenalty'),
                    aiPieces: document.getElementById('aiPieces'),
                    aiKings: document.getElementById('aiKings'),
                    turnText: document.getElementById('turnText'),
                    turnIndicator: document.getElementById('turnIndicator'),
                    moveHistory: document.getElementById('moveHistory'),
                    gameOverModal: document.getElementById('gameOverModal'),
                    resultTitle: document.getElementById('resultTitle'),
                    resultIcon: document.getElementById('resultIcon'),
                    resultMessage: document.getElementById('resultMessage'),
                    totalMoves: document.getElementById('totalMoves'),
                    totalCaptures: document.getElementById('totalCaptures'),
                    gameTime: document.getElementById('gameTime'),
                    newGameBtn: document.getElementById('newGame'),
                    undoBtn: document.getElementById('undoBtn'),
                    hintBtn: document.getElementById('hintBtn'),
                    playAgainBtn: document.getElementById('playAgainBtn'),
                    closeModalBtn: document.getElementById('closeModalBtn'),
                    soundToggle: document.getElementById('soundToggle'),
                    animationToggle: document.getElementById('animationToggle'),
                    aiThinking: document.getElementById('aiThinking')
                };
            }

            bindEvents() {
                this.elements.newGameBtn.addEventListener('click', () => this.game.newGame());
                this.elements.undoBtn.addEventListener('click', () => this.game.undoMove());
                this.elements.hintBtn.addEventListener('click', () => this.game.getHint());
                this.elements.playAgainBtn.addEventListener('click', () => this.game.newGame());
                this.elements.closeModalBtn.addEventListener('click', () => this.hideGameOverModal());
                this.elements.soundToggle.addEventListener('change', (e) => {
                    this.game.toggleSound();
                });
                this.elements.animationToggle.addEventListener('change', (e) => {
                    this.game.toggleAnimation();
                });
            }

            createBoard() {
                this.elements.board.innerHTML = '';
                
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const cell = document.createElement('div');
                        cell.className = `cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        cell.addEventListener('click', () => {
                            this.game.handleCellClick(row, col);
                        });
                        
                        this.elements.board.appendChild(cell);
                    }
                }
            }

            updateBoard(board) {
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const cell = this.getCellElement(row, col);
                        cell.innerHTML = '';
                        cell.classList.remove('selected', 'valid-move', 'valid-capture');
                        
                        const piece = board[row][col];
                        if (piece) {
                            const pieceElement = this.createPieceElement(piece);
                            cell.appendChild(pieceElement);
                        }
                    }
                }
            }

            getCellElement(row, col) {
                const index = row * BOARD_SIZE + col;
                return this.elements.board.children[index];
            }

            createPieceElement(piece) {
                const pieceElement = document.createElement('div');
                pieceElement.className = `piece ${piece.player}`;
                pieceElement.dataset.row = piece.row;
                pieceElement.dataset.col = piece.col;
                
                if (piece.type === PIECE_TYPE.KING) {
                    pieceElement.classList.add('king');
                    const kingSymbol = document.createElement('div');
                    kingSymbol.className = 'king-symbol';
                    kingSymbol.textContent = '‚ôî';
                    pieceElement.appendChild(kingSymbol);
                }
                
                return pieceElement;
            }

            highlightPiece(piece) {
                const cell = this.getCellElement(piece.row, piece.col);
                cell.classList.add('selected');
                
                const pieceElement = cell.querySelector('.piece');
                if (pieceElement) {
                    pieceElement.classList.add('selected');
                }
            }

            highlightValidMoves(moves) {
                moves.forEach(move => {
                    const cell = this.getCellElement(move.to.row, move.to.col);
                    if (move.isCapture) {
                        cell.classList.add('valid-capture');
                    } else {
                        cell.classList.add('valid-move');
                    }
                });
            }

            clearHighlights() {
                const cells = this.elements.board.children;
                for (let cell of cells) {
                    cell.classList.remove('selected', 'valid-move', 'valid-capture');
                    const piece = cell.querySelector('.piece');
                    if (piece) {
                        piece.classList.remove('selected');
                    }
                }
            }

            clearMoveHistory() {
                this.elements.moveHistory.innerHTML = '';
            }

            updatePlayerInfo(playerPieces, playerKings, aiPieces, aiKings, playerPenalty) {
                this.elements.playerPieces.textContent = playerPieces;
                this.elements.playerKings.textContent = playerKings;
                this.elements.aiPieces.textContent = aiPieces;
                this.elements.aiKings.textContent = aiKings;
                this.elements.playerPenalty.textContent = `${playerPenalty}/3`;
            }

            updateTurnIndicator(currentPlayer) {
                if (currentPlayer === PLAYER.HUMAN) {
                    this.elements.turnIndicator.className = 'turn-indicator white';
                    this.elements.turnText.textContent = "Sizning navbatingiz";
                } else {
                    this.elements.turnIndicator.className = 'turn-indicator black';
                    this.elements.turnText.textContent = "AI kombinatsiya qilmoqda";
                }
            }

            showMessage(message) {
                this.elements.gameStatus.textContent = message;
            }

            showHint(move) {
                this.clearHighlights();
                this.highlightPiece(move.piece);
                
                const targetCell = this.getCellElement(move.to.row, move.to.col);
                if (move.isCapture) {
                    targetCell.classList.add('valid-capture');
                } else {
                    targetCell.classList.add('valid-move');
                }
                
                setTimeout(() => {
                    this.clearHighlights();
                }, 4000);
            }

            addMoveToHistory(entry) {
                const moveElement = document.createElement('div');
                moveElement.className = `move-entry ${entry.player}`;
                moveElement.textContent = entry.text;
                
                this.elements.moveHistory.appendChild(moveElement);
                this.elements.moveHistory.scrollTop = this.elements.moveHistory.scrollHeight;
                
                if (this.elements.moveHistory.children.length > 50) {
                    this.elements.moveHistory.removeChild(this.elements.moveHistory.firstChild);
                }
            }

            showGameOver(isHumanWinner, minutes, seconds, totalMoves, totalCaptures) {
                if (isHumanWinner) {
                    this.elements.resultTitle.textContent = "TABRIKLAYMIZ!";
                    this.elements.resultIcon.textContent = "üèÜ";
                    this.elements.resultMessage.textContent = "Siz yengilmas kombinatsiya AIni yutdingiz! Bu ajoyib natija.";
                } else {
                    this.elements.resultTitle.textContent = "AFSUSKI...";
                    this.elements.resultIcon.textContent = "üíÄ";
                    this.elements.resultMessage.textContent = "Siz yutqazdingiz. AI kombinatsiyalari ustun keldi. Yana urinib ko'ring!";
                }
                
                this.elements.totalMoves.textContent = totalMoves;
                this.elements.totalCaptures.textContent = totalCaptures;
                this.elements.gameTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                this.elements.gameOverModal.classList.add('active');
            }

            hideGameOverModal() {
                this.elements.gameOverModal.classList.remove('active');
            }

            updateSoundButton(soundEnabled) {
                this.elements.soundToggle.checked = soundEnabled;
            }

            updateAnimationButton(animationEnabled) {
                this.elements.animationToggle.checked = animationEnabled;
            }

            showAIThinking(show) {
                if (show) {
                    this.elements.aiThinking.style.display = 'flex';
                    this.elements.turnIndicator.classList.add('ai-thinking');
                    
                    setTimeout(() => {
                        this.elements.aiThinking.style.display = 'none';
                        this.elements.turnIndicator.classList.remove('ai-thinking');
                    }, 500);
                } else {
                    this.elements.aiThinking.style.display = 'none';
                    this.elements.turnIndicator.classList.remove('ai-thinking');
                }
            }
        }

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new ShashkaGame();
            
            function updateBoardSize() {
                const board = document.querySelector('.board');
                if (!board) return;
                
                const isMobile = window.innerWidth <= 768;
                
                if (isMobile) {
                    const maxSize = Math.min(window.innerWidth * 0.92, window.innerHeight * 0.65);
                    const size = Math.max(maxSize, 300);
                    document.documentElement.style.setProperty('--board-size', `${size}px`);
                    
                    const cellSize = size / 8;
                    document.querySelectorAll('.cell').forEach(cell => {
                        cell.style.minHeight = `${cellSize}px`;
                        cell.style.minWidth = `${cellSize}px`;
                    });
                } else {
                    const container = document.querySelector('.game-board-container');
                    const availableWidth = container ? container.clientWidth - 40 : window.innerWidth - 40;
                    const availableHeight = window.innerHeight * 0.7;
                    const size = Math.min(availableWidth, availableHeight, 600, 500);
                    document.documentElement.style.setProperty('--board-size', `${size}px`);
                }
            }

            updateBoardSize();
            window.addEventListener('resize', updateBoardSize);
            window.addEventListener('orientationchange', updateBoardSize);

            // Mobile optimizations
            if ('ontouchstart' in window) {
                const style = document.createElement('style');
                style.textContent = `
                    @media (hover: none) and (pointer: coarse) {
                        .cell {
                            min-height: 35px !important;
                            min-width: 35px !important;
                        }
                        
                        .piece {
                            width: 80% !important;
                            height: 80% !important;
                        }
                        
                        .btn {
                            min-height: 44px;
                            min-width: 44px;
                        }
                        
                        .king-symbol {
                            font-size: 1.1rem !important;
                        }
                        
                        .cell.valid-move::after {
                            width: 15px !important;
                            height: 15px !important;
                        }
                        
                        .cell.valid-capture::after {
                            width: 18px !important;
                            height: 18px !important;
                        }
                    }
                    
                    @media (max-width: 375px) {
                        .cell {
                            min-height: 30px !important;
                            min-width: 30px !important;
                        }
                        
                        .piece {
                            width: 75% !important;
                            height: 75% !important;
                        }
                        
                        .king-symbol {
                            font-size: 0.9rem !important;
                        }
                    }
                `;
                document.head.appendChild(style);
                
                document.querySelectorAll('.cell, .piece, .btn').forEach(el => {
                    el.style.touchAction = 'manipulation';
                    el.style.webkitTapHighlightColor = 'transparent';
                });
            }
            
            document.querySelectorAll('.btn').forEach(btn => {
                btn.style.touchAction = 'manipulation';
                btn.style.userSelect = 'none';
            });
            
            const board = document.querySelector('.board');
            if (board) {
                board.style.touchAction = 'manipulation';
                board.style.webkitTapHighlightColor = 'transparent';
            }
        });
    </script>
</body>
</html>
